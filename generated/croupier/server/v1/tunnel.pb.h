// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: croupier/server/v1/tunnel.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_croupier_2fserver_2fv1_2ftunnel_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_croupier_2fserver_2fv1_2ftunnel_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_croupier_2fserver_2fv1_2ftunnel_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_croupier_2fserver_2fv1_2ftunnel_2eproto;
namespace croupier {
namespace server {
namespace v1 {
class CancelJobFrame;
struct CancelJobFrameDefaultTypeInternal;
extern CancelJobFrameDefaultTypeInternal _CancelJobFrame_default_instance_;
class Hello;
struct HelloDefaultTypeInternal;
extern HelloDefaultTypeInternal _Hello_default_instance_;
class InvokeFrame;
struct InvokeFrameDefaultTypeInternal;
extern InvokeFrameDefaultTypeInternal _InvokeFrame_default_instance_;
class InvokeFrame_MetadataEntry_DoNotUse;
struct InvokeFrame_MetadataEntry_DoNotUseDefaultTypeInternal;
extern InvokeFrame_MetadataEntry_DoNotUseDefaultTypeInternal _InvokeFrame_MetadataEntry_DoNotUse_default_instance_;
class JobEventFrame;
struct JobEventFrameDefaultTypeInternal;
extern JobEventFrameDefaultTypeInternal _JobEventFrame_default_instance_;
class ListLocalRequest;
struct ListLocalRequestDefaultTypeInternal;
extern ListLocalRequestDefaultTypeInternal _ListLocalRequest_default_instance_;
class ListLocalResponse;
struct ListLocalResponseDefaultTypeInternal;
extern ListLocalResponseDefaultTypeInternal _ListLocalResponse_default_instance_;
class ResultFrame;
struct ResultFrameDefaultTypeInternal;
extern ResultFrameDefaultTypeInternal _ResultFrame_default_instance_;
class StartJobFrame;
struct StartJobFrameDefaultTypeInternal;
extern StartJobFrameDefaultTypeInternal _StartJobFrame_default_instance_;
class StartJobFrame_MetadataEntry_DoNotUse;
struct StartJobFrame_MetadataEntry_DoNotUseDefaultTypeInternal;
extern StartJobFrame_MetadataEntry_DoNotUseDefaultTypeInternal _StartJobFrame_MetadataEntry_DoNotUse_default_instance_;
class StartJobResult;
struct StartJobResultDefaultTypeInternal;
extern StartJobResultDefaultTypeInternal _StartJobResult_default_instance_;
class TunnelJobResultRequest;
struct TunnelJobResultRequestDefaultTypeInternal;
extern TunnelJobResultRequestDefaultTypeInternal _TunnelJobResultRequest_default_instance_;
class TunnelJobResultResponse;
struct TunnelJobResultResponseDefaultTypeInternal;
extern TunnelJobResultResponseDefaultTypeInternal _TunnelJobResultResponse_default_instance_;
class TunnelMessage;
struct TunnelMessageDefaultTypeInternal;
extern TunnelMessageDefaultTypeInternal _TunnelMessage_default_instance_;
}  // namespace v1
}  // namespace server
}  // namespace croupier
PROTOBUF_NAMESPACE_OPEN
template<> ::croupier::server::v1::CancelJobFrame* Arena::CreateMaybeMessage<::croupier::server::v1::CancelJobFrame>(Arena*);
template<> ::croupier::server::v1::Hello* Arena::CreateMaybeMessage<::croupier::server::v1::Hello>(Arena*);
template<> ::croupier::server::v1::InvokeFrame* Arena::CreateMaybeMessage<::croupier::server::v1::InvokeFrame>(Arena*);
template<> ::croupier::server::v1::InvokeFrame_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::croupier::server::v1::InvokeFrame_MetadataEntry_DoNotUse>(Arena*);
template<> ::croupier::server::v1::JobEventFrame* Arena::CreateMaybeMessage<::croupier::server::v1::JobEventFrame>(Arena*);
template<> ::croupier::server::v1::ListLocalRequest* Arena::CreateMaybeMessage<::croupier::server::v1::ListLocalRequest>(Arena*);
template<> ::croupier::server::v1::ListLocalResponse* Arena::CreateMaybeMessage<::croupier::server::v1::ListLocalResponse>(Arena*);
template<> ::croupier::server::v1::ResultFrame* Arena::CreateMaybeMessage<::croupier::server::v1::ResultFrame>(Arena*);
template<> ::croupier::server::v1::StartJobFrame* Arena::CreateMaybeMessage<::croupier::server::v1::StartJobFrame>(Arena*);
template<> ::croupier::server::v1::StartJobFrame_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::croupier::server::v1::StartJobFrame_MetadataEntry_DoNotUse>(Arena*);
template<> ::croupier::server::v1::StartJobResult* Arena::CreateMaybeMessage<::croupier::server::v1::StartJobResult>(Arena*);
template<> ::croupier::server::v1::TunnelJobResultRequest* Arena::CreateMaybeMessage<::croupier::server::v1::TunnelJobResultRequest>(Arena*);
template<> ::croupier::server::v1::TunnelJobResultResponse* Arena::CreateMaybeMessage<::croupier::server::v1::TunnelJobResultResponse>(Arena*);
template<> ::croupier::server::v1::TunnelMessage* Arena::CreateMaybeMessage<::croupier::server::v1::TunnelMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace croupier {
namespace server {
namespace v1 {

// ===================================================================

class Hello final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.Hello) */ {
 public:
  inline Hello() : Hello(nullptr) {}
  ~Hello() override;
  explicit PROTOBUF_CONSTEXPR Hello(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hello(const Hello& from);
  Hello(Hello&& from) noexcept
    : Hello() {
    *this = ::std::move(from);
  }

  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hello& operator=(Hello&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hello& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hello* internal_default_instance() {
    return reinterpret_cast<const Hello*>(
               &_Hello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Hello& a, Hello& b) {
    a.Swap(&b);
  }
  inline void Swap(Hello* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hello* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hello* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hello>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hello& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hello& from) {
    Hello::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hello* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.Hello";
  }
  protected:
  explicit Hello(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentIdFieldNumber = 1,
    kGameIdFieldNumber = 2,
    kEnvFieldNumber = 3,
  };
  // string agent_id = 1;
  void clear_agent_id();
  const std::string& agent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* agent_id);
  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(const std::string& value);
  std::string* _internal_mutable_agent_id();
  public:

  // string game_id = 2;
  void clear_game_id();
  const std::string& game_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_id();
  PROTOBUF_NODISCARD std::string* release_game_id();
  void set_allocated_game_id(std::string* game_id);
  private:
  const std::string& _internal_game_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_id(const std::string& value);
  std::string* _internal_mutable_game_id();
  public:

  // string env = 3;
  void clear_env();
  const std::string& env() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_env(ArgT0&& arg0, ArgT... args);
  std::string* mutable_env();
  PROTOBUF_NODISCARD std::string* release_env();
  void set_allocated_env(std::string* env);
  private:
  const std::string& _internal_env() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_env(const std::string& value);
  std::string* _internal_mutable_env();
  public:

  // @@protoc_insertion_point(class_scope:croupier.server.v1.Hello)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr env_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// -------------------------------------------------------------------

class InvokeFrame_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InvokeFrame_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InvokeFrame_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  InvokeFrame_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR InvokeFrame_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InvokeFrame_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InvokeFrame_MetadataEntry_DoNotUse& other);
  static const InvokeFrame_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InvokeFrame_MetadataEntry_DoNotUse*>(&_InvokeFrame_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "croupier.server.v1.InvokeFrame.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "croupier.server.v1.InvokeFrame.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};

// -------------------------------------------------------------------

class InvokeFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.InvokeFrame) */ {
 public:
  inline InvokeFrame() : InvokeFrame(nullptr) {}
  ~InvokeFrame() override;
  explicit PROTOBUF_CONSTEXPR InvokeFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeFrame(const InvokeFrame& from);
  InvokeFrame(InvokeFrame&& from) noexcept
    : InvokeFrame() {
    *this = ::std::move(from);
  }

  inline InvokeFrame& operator=(const InvokeFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeFrame& operator=(InvokeFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeFrame* internal_default_instance() {
    return reinterpret_cast<const InvokeFrame*>(
               &_InvokeFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InvokeFrame& a, InvokeFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeFrame& from) {
    InvokeFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.InvokeFrame";
  }
  protected:
  explicit InvokeFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kFunctionIdFieldNumber = 2,
    kIdempotencyKeyFieldNumber = 3,
    kPayloadFieldNumber = 4,
  };
  // map<string, string> metadata = 5;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string function_id = 2;
  void clear_function_id();
  const std::string& function_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_id();
  PROTOBUF_NODISCARD std::string* release_function_id();
  void set_allocated_function_id(std::string* function_id);
  private:
  const std::string& _internal_function_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_id(const std::string& value);
  std::string* _internal_mutable_function_id();
  public:

  // string idempotency_key = 3;
  void clear_idempotency_key();
  const std::string& idempotency_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idempotency_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idempotency_key();
  PROTOBUF_NODISCARD std::string* release_idempotency_key();
  void set_allocated_idempotency_key(std::string* idempotency_key);
  private:
  const std::string& _internal_idempotency_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idempotency_key(const std::string& value);
  std::string* _internal_mutable_idempotency_key();
  public:

  // bytes payload = 4;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:croupier.server.v1.InvokeFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        InvokeFrame_MetadataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idempotency_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// -------------------------------------------------------------------

class StartJobFrame_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StartJobFrame_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StartJobFrame_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  StartJobFrame_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR StartJobFrame_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit StartJobFrame_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StartJobFrame_MetadataEntry_DoNotUse& other);
  static const StartJobFrame_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StartJobFrame_MetadataEntry_DoNotUse*>(&_StartJobFrame_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "croupier.server.v1.StartJobFrame.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "croupier.server.v1.StartJobFrame.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};

// -------------------------------------------------------------------

class StartJobFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.StartJobFrame) */ {
 public:
  inline StartJobFrame() : StartJobFrame(nullptr) {}
  ~StartJobFrame() override;
  explicit PROTOBUF_CONSTEXPR StartJobFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartJobFrame(const StartJobFrame& from);
  StartJobFrame(StartJobFrame&& from) noexcept
    : StartJobFrame() {
    *this = ::std::move(from);
  }

  inline StartJobFrame& operator=(const StartJobFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartJobFrame& operator=(StartJobFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartJobFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartJobFrame* internal_default_instance() {
    return reinterpret_cast<const StartJobFrame*>(
               &_StartJobFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StartJobFrame& a, StartJobFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(StartJobFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartJobFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartJobFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartJobFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartJobFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartJobFrame& from) {
    StartJobFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartJobFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.StartJobFrame";
  }
  protected:
  explicit StartJobFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kFunctionIdFieldNumber = 2,
    kIdempotencyKeyFieldNumber = 3,
    kPayloadFieldNumber = 4,
  };
  // map<string, string> metadata = 5;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string function_id = 2;
  void clear_function_id();
  const std::string& function_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_id();
  PROTOBUF_NODISCARD std::string* release_function_id();
  void set_allocated_function_id(std::string* function_id);
  private:
  const std::string& _internal_function_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_id(const std::string& value);
  std::string* _internal_mutable_function_id();
  public:

  // string idempotency_key = 3;
  void clear_idempotency_key();
  const std::string& idempotency_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idempotency_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idempotency_key();
  PROTOBUF_NODISCARD std::string* release_idempotency_key();
  void set_allocated_idempotency_key(std::string* idempotency_key);
  private:
  const std::string& _internal_idempotency_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idempotency_key(const std::string& value);
  std::string* _internal_mutable_idempotency_key();
  public:

  // bytes payload = 4;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:croupier.server.v1.StartJobFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        StartJobFrame_MetadataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idempotency_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// -------------------------------------------------------------------

class CancelJobFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.CancelJobFrame) */ {
 public:
  inline CancelJobFrame() : CancelJobFrame(nullptr) {}
  ~CancelJobFrame() override;
  explicit PROTOBUF_CONSTEXPR CancelJobFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelJobFrame(const CancelJobFrame& from);
  CancelJobFrame(CancelJobFrame&& from) noexcept
    : CancelJobFrame() {
    *this = ::std::move(from);
  }

  inline CancelJobFrame& operator=(const CancelJobFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelJobFrame& operator=(CancelJobFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelJobFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelJobFrame* internal_default_instance() {
    return reinterpret_cast<const CancelJobFrame*>(
               &_CancelJobFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CancelJobFrame& a, CancelJobFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelJobFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelJobFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelJobFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelJobFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelJobFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelJobFrame& from) {
    CancelJobFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelJobFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.CancelJobFrame";
  }
  protected:
  explicit CancelJobFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // @@protoc_insertion_point(class_scope:croupier.server.v1.CancelJobFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// -------------------------------------------------------------------

class ResultFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.ResultFrame) */ {
 public:
  inline ResultFrame() : ResultFrame(nullptr) {}
  ~ResultFrame() override;
  explicit PROTOBUF_CONSTEXPR ResultFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultFrame(const ResultFrame& from);
  ResultFrame(ResultFrame&& from) noexcept
    : ResultFrame() {
    *this = ::std::move(from);
  }

  inline ResultFrame& operator=(const ResultFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultFrame& operator=(ResultFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResultFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResultFrame* internal_default_instance() {
    return reinterpret_cast<const ResultFrame*>(
               &_ResultFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ResultFrame& a, ResultFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResultFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResultFrame& from) {
    ResultFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.ResultFrame";
  }
  protected:
  explicit ResultFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kPayloadFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // bytes payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // string error = 3;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:croupier.server.v1.ResultFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// -------------------------------------------------------------------

class StartJobResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.StartJobResult) */ {
 public:
  inline StartJobResult() : StartJobResult(nullptr) {}
  ~StartJobResult() override;
  explicit PROTOBUF_CONSTEXPR StartJobResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartJobResult(const StartJobResult& from);
  StartJobResult(StartJobResult&& from) noexcept
    : StartJobResult() {
    *this = ::std::move(from);
  }

  inline StartJobResult& operator=(const StartJobResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartJobResult& operator=(StartJobResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartJobResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartJobResult* internal_default_instance() {
    return reinterpret_cast<const StartJobResult*>(
               &_StartJobResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StartJobResult& a, StartJobResult& b) {
    a.Swap(&b);
  }
  inline void Swap(StartJobResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartJobResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartJobResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartJobResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartJobResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartJobResult& from) {
    StartJobResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartJobResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.StartJobResult";
  }
  protected:
  explicit StartJobResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kJobIdFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string job_id = 2;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string error = 3;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:croupier.server.v1.StartJobResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// -------------------------------------------------------------------

class JobEventFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.JobEventFrame) */ {
 public:
  inline JobEventFrame() : JobEventFrame(nullptr) {}
  ~JobEventFrame() override;
  explicit PROTOBUF_CONSTEXPR JobEventFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobEventFrame(const JobEventFrame& from);
  JobEventFrame(JobEventFrame&& from) noexcept
    : JobEventFrame() {
    *this = ::std::move(from);
  }

  inline JobEventFrame& operator=(const JobEventFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobEventFrame& operator=(JobEventFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobEventFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobEventFrame* internal_default_instance() {
    return reinterpret_cast<const JobEventFrame*>(
               &_JobEventFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(JobEventFrame& a, JobEventFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(JobEventFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobEventFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobEventFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobEventFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobEventFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobEventFrame& from) {
    JobEventFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobEventFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.JobEventFrame";
  }
  protected:
  explicit JobEventFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kMessageFieldNumber = 3,
    kPayloadFieldNumber = 5,
    kProgressFieldNumber = 4,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bytes payload = 5;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // int32 progress = 4;
  void clear_progress();
  int32_t progress() const;
  void set_progress(int32_t value);
  private:
  int32_t _internal_progress() const;
  void _internal_set_progress(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:croupier.server.v1.JobEventFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    int32_t progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// -------------------------------------------------------------------

class ListLocalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.ListLocalRequest) */ {
 public:
  inline ListLocalRequest() : ListLocalRequest(nullptr) {}
  ~ListLocalRequest() override;
  explicit PROTOBUF_CONSTEXPR ListLocalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListLocalRequest(const ListLocalRequest& from);
  ListLocalRequest(ListLocalRequest&& from) noexcept
    : ListLocalRequest() {
    *this = ::std::move(from);
  }

  inline ListLocalRequest& operator=(const ListLocalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLocalRequest& operator=(ListLocalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListLocalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListLocalRequest* internal_default_instance() {
    return reinterpret_cast<const ListLocalRequest*>(
               &_ListLocalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListLocalRequest& a, ListLocalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLocalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLocalRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListLocalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListLocalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListLocalRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListLocalRequest& from) {
    ListLocalRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLocalRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.ListLocalRequest";
  }
  protected:
  explicit ListLocalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kFunctionIdFieldNumber = 2,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string function_id = 2;
  void clear_function_id();
  const std::string& function_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_id();
  PROTOBUF_NODISCARD std::string* release_function_id();
  void set_allocated_function_id(std::string* function_id);
  private:
  const std::string& _internal_function_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_id(const std::string& value);
  std::string* _internal_mutable_function_id();
  public:

  // @@protoc_insertion_point(class_scope:croupier.server.v1.ListLocalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// -------------------------------------------------------------------

class ListLocalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.ListLocalResponse) */ {
 public:
  inline ListLocalResponse() : ListLocalResponse(nullptr) {}
  ~ListLocalResponse() override;
  explicit PROTOBUF_CONSTEXPR ListLocalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListLocalResponse(const ListLocalResponse& from);
  ListLocalResponse(ListLocalResponse&& from) noexcept
    : ListLocalResponse() {
    *this = ::std::move(from);
  }

  inline ListLocalResponse& operator=(const ListLocalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLocalResponse& operator=(ListLocalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListLocalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListLocalResponse* internal_default_instance() {
    return reinterpret_cast<const ListLocalResponse*>(
               &_ListLocalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ListLocalResponse& a, ListLocalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLocalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLocalResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListLocalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListLocalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListLocalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListLocalResponse& from) {
    ListLocalResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLocalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.ListLocalResponse";
  }
  protected:
  explicit ListLocalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceIdsFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kFunctionIdFieldNumber = 2,
    kErrorFieldNumber = 4,
  };
  // repeated string service_ids = 3;
  int service_ids_size() const;
  private:
  int _internal_service_ids_size() const;
  public:
  void clear_service_ids();
  const std::string& service_ids(int index) const;
  std::string* mutable_service_ids(int index);
  void set_service_ids(int index, const std::string& value);
  void set_service_ids(int index, std::string&& value);
  void set_service_ids(int index, const char* value);
  void set_service_ids(int index, const char* value, size_t size);
  std::string* add_service_ids();
  void add_service_ids(const std::string& value);
  void add_service_ids(std::string&& value);
  void add_service_ids(const char* value);
  void add_service_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& service_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_service_ids();
  private:
  const std::string& _internal_service_ids(int index) const;
  std::string* _internal_add_service_ids();
  public:

  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string function_id = 2;
  void clear_function_id();
  const std::string& function_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_id();
  PROTOBUF_NODISCARD std::string* release_function_id();
  void set_allocated_function_id(std::string* function_id);
  private:
  const std::string& _internal_function_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_id(const std::string& value);
  std::string* _internal_mutable_function_id();
  public:

  // string error = 4;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:croupier.server.v1.ListLocalResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> service_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// -------------------------------------------------------------------

class TunnelJobResultRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.TunnelJobResultRequest) */ {
 public:
  inline TunnelJobResultRequest() : TunnelJobResultRequest(nullptr) {}
  ~TunnelJobResultRequest() override;
  explicit PROTOBUF_CONSTEXPR TunnelJobResultRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TunnelJobResultRequest(const TunnelJobResultRequest& from);
  TunnelJobResultRequest(TunnelJobResultRequest&& from) noexcept
    : TunnelJobResultRequest() {
    *this = ::std::move(from);
  }

  inline TunnelJobResultRequest& operator=(const TunnelJobResultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TunnelJobResultRequest& operator=(TunnelJobResultRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TunnelJobResultRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TunnelJobResultRequest* internal_default_instance() {
    return reinterpret_cast<const TunnelJobResultRequest*>(
               &_TunnelJobResultRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TunnelJobResultRequest& a, TunnelJobResultRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TunnelJobResultRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TunnelJobResultRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TunnelJobResultRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TunnelJobResultRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TunnelJobResultRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TunnelJobResultRequest& from) {
    TunnelJobResultRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelJobResultRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.TunnelJobResultRequest";
  }
  protected:
  explicit TunnelJobResultRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kJobIdFieldNumber = 2,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string job_id = 2;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // @@protoc_insertion_point(class_scope:croupier.server.v1.TunnelJobResultRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// -------------------------------------------------------------------

class TunnelJobResultResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.TunnelJobResultResponse) */ {
 public:
  inline TunnelJobResultResponse() : TunnelJobResultResponse(nullptr) {}
  ~TunnelJobResultResponse() override;
  explicit PROTOBUF_CONSTEXPR TunnelJobResultResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TunnelJobResultResponse(const TunnelJobResultResponse& from);
  TunnelJobResultResponse(TunnelJobResultResponse&& from) noexcept
    : TunnelJobResultResponse() {
    *this = ::std::move(from);
  }

  inline TunnelJobResultResponse& operator=(const TunnelJobResultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TunnelJobResultResponse& operator=(TunnelJobResultResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TunnelJobResultResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TunnelJobResultResponse* internal_default_instance() {
    return reinterpret_cast<const TunnelJobResultResponse*>(
               &_TunnelJobResultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TunnelJobResultResponse& a, TunnelJobResultResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TunnelJobResultResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TunnelJobResultResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TunnelJobResultResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TunnelJobResultResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TunnelJobResultResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TunnelJobResultResponse& from) {
    TunnelJobResultResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelJobResultResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.TunnelJobResultResponse";
  }
  protected:
  explicit TunnelJobResultResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kStateFieldNumber = 2,
    kPayloadFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string state = 2;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // bytes payload = 3;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // string error = 4;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:croupier.server.v1.TunnelJobResultResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// -------------------------------------------------------------------

class TunnelMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:croupier.server.v1.TunnelMessage) */ {
 public:
  inline TunnelMessage() : TunnelMessage(nullptr) {}
  ~TunnelMessage() override;
  explicit PROTOBUF_CONSTEXPR TunnelMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TunnelMessage(const TunnelMessage& from);
  TunnelMessage(TunnelMessage&& from) noexcept
    : TunnelMessage() {
    *this = ::std::move(from);
  }

  inline TunnelMessage& operator=(const TunnelMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TunnelMessage& operator=(TunnelMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TunnelMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TunnelMessage* internal_default_instance() {
    return reinterpret_cast<const TunnelMessage*>(
               &_TunnelMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TunnelMessage& a, TunnelMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TunnelMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TunnelMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TunnelMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TunnelMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TunnelMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TunnelMessage& from) {
    TunnelMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "croupier.server.v1.TunnelMessage";
  }
  protected:
  explicit TunnelMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kHelloFieldNumber = 2,
    kResultFieldNumber = 3,
    kStartRFieldNumber = 4,
    kJobEvtFieldNumber = 5,
    kListReqFieldNumber = 6,
    kListResFieldNumber = 7,
    kJobResReqFieldNumber = 8,
    kJobResResFieldNumber = 9,
    kInvokeFieldNumber = 10,
    kStartFieldNumber = 11,
    kCancelFieldNumber = 12,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .croupier.server.v1.Hello hello = 2;
  bool has_hello() const;
  private:
  bool _internal_has_hello() const;
  public:
  void clear_hello();
  const ::croupier::server::v1::Hello& hello() const;
  PROTOBUF_NODISCARD ::croupier::server::v1::Hello* release_hello();
  ::croupier::server::v1::Hello* mutable_hello();
  void set_allocated_hello(::croupier::server::v1::Hello* hello);
  private:
  const ::croupier::server::v1::Hello& _internal_hello() const;
  ::croupier::server::v1::Hello* _internal_mutable_hello();
  public:
  void unsafe_arena_set_allocated_hello(
      ::croupier::server::v1::Hello* hello);
  ::croupier::server::v1::Hello* unsafe_arena_release_hello();

  // .croupier.server.v1.ResultFrame result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::croupier::server::v1::ResultFrame& result() const;
  PROTOBUF_NODISCARD ::croupier::server::v1::ResultFrame* release_result();
  ::croupier::server::v1::ResultFrame* mutable_result();
  void set_allocated_result(::croupier::server::v1::ResultFrame* result);
  private:
  const ::croupier::server::v1::ResultFrame& _internal_result() const;
  ::croupier::server::v1::ResultFrame* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::croupier::server::v1::ResultFrame* result);
  ::croupier::server::v1::ResultFrame* unsafe_arena_release_result();

  // .croupier.server.v1.StartJobResult start_r = 4;
  bool has_start_r() const;
  private:
  bool _internal_has_start_r() const;
  public:
  void clear_start_r();
  const ::croupier::server::v1::StartJobResult& start_r() const;
  PROTOBUF_NODISCARD ::croupier::server::v1::StartJobResult* release_start_r();
  ::croupier::server::v1::StartJobResult* mutable_start_r();
  void set_allocated_start_r(::croupier::server::v1::StartJobResult* start_r);
  private:
  const ::croupier::server::v1::StartJobResult& _internal_start_r() const;
  ::croupier::server::v1::StartJobResult* _internal_mutable_start_r();
  public:
  void unsafe_arena_set_allocated_start_r(
      ::croupier::server::v1::StartJobResult* start_r);
  ::croupier::server::v1::StartJobResult* unsafe_arena_release_start_r();

  // .croupier.server.v1.JobEventFrame job_evt = 5;
  bool has_job_evt() const;
  private:
  bool _internal_has_job_evt() const;
  public:
  void clear_job_evt();
  const ::croupier::server::v1::JobEventFrame& job_evt() const;
  PROTOBUF_NODISCARD ::croupier::server::v1::JobEventFrame* release_job_evt();
  ::croupier::server::v1::JobEventFrame* mutable_job_evt();
  void set_allocated_job_evt(::croupier::server::v1::JobEventFrame* job_evt);
  private:
  const ::croupier::server::v1::JobEventFrame& _internal_job_evt() const;
  ::croupier::server::v1::JobEventFrame* _internal_mutable_job_evt();
  public:
  void unsafe_arena_set_allocated_job_evt(
      ::croupier::server::v1::JobEventFrame* job_evt);
  ::croupier::server::v1::JobEventFrame* unsafe_arena_release_job_evt();

  // .croupier.server.v1.ListLocalRequest list_req = 6;
  bool has_list_req() const;
  private:
  bool _internal_has_list_req() const;
  public:
  void clear_list_req();
  const ::croupier::server::v1::ListLocalRequest& list_req() const;
  PROTOBUF_NODISCARD ::croupier::server::v1::ListLocalRequest* release_list_req();
  ::croupier::server::v1::ListLocalRequest* mutable_list_req();
  void set_allocated_list_req(::croupier::server::v1::ListLocalRequest* list_req);
  private:
  const ::croupier::server::v1::ListLocalRequest& _internal_list_req() const;
  ::croupier::server::v1::ListLocalRequest* _internal_mutable_list_req();
  public:
  void unsafe_arena_set_allocated_list_req(
      ::croupier::server::v1::ListLocalRequest* list_req);
  ::croupier::server::v1::ListLocalRequest* unsafe_arena_release_list_req();

  // .croupier.server.v1.ListLocalResponse list_res = 7;
  bool has_list_res() const;
  private:
  bool _internal_has_list_res() const;
  public:
  void clear_list_res();
  const ::croupier::server::v1::ListLocalResponse& list_res() const;
  PROTOBUF_NODISCARD ::croupier::server::v1::ListLocalResponse* release_list_res();
  ::croupier::server::v1::ListLocalResponse* mutable_list_res();
  void set_allocated_list_res(::croupier::server::v1::ListLocalResponse* list_res);
  private:
  const ::croupier::server::v1::ListLocalResponse& _internal_list_res() const;
  ::croupier::server::v1::ListLocalResponse* _internal_mutable_list_res();
  public:
  void unsafe_arena_set_allocated_list_res(
      ::croupier::server::v1::ListLocalResponse* list_res);
  ::croupier::server::v1::ListLocalResponse* unsafe_arena_release_list_res();

  // .croupier.server.v1.TunnelJobResultRequest job_res_req = 8;
  bool has_job_res_req() const;
  private:
  bool _internal_has_job_res_req() const;
  public:
  void clear_job_res_req();
  const ::croupier::server::v1::TunnelJobResultRequest& job_res_req() const;
  PROTOBUF_NODISCARD ::croupier::server::v1::TunnelJobResultRequest* release_job_res_req();
  ::croupier::server::v1::TunnelJobResultRequest* mutable_job_res_req();
  void set_allocated_job_res_req(::croupier::server::v1::TunnelJobResultRequest* job_res_req);
  private:
  const ::croupier::server::v1::TunnelJobResultRequest& _internal_job_res_req() const;
  ::croupier::server::v1::TunnelJobResultRequest* _internal_mutable_job_res_req();
  public:
  void unsafe_arena_set_allocated_job_res_req(
      ::croupier::server::v1::TunnelJobResultRequest* job_res_req);
  ::croupier::server::v1::TunnelJobResultRequest* unsafe_arena_release_job_res_req();

  // .croupier.server.v1.TunnelJobResultResponse job_res_res = 9;
  bool has_job_res_res() const;
  private:
  bool _internal_has_job_res_res() const;
  public:
  void clear_job_res_res();
  const ::croupier::server::v1::TunnelJobResultResponse& job_res_res() const;
  PROTOBUF_NODISCARD ::croupier::server::v1::TunnelJobResultResponse* release_job_res_res();
  ::croupier::server::v1::TunnelJobResultResponse* mutable_job_res_res();
  void set_allocated_job_res_res(::croupier::server::v1::TunnelJobResultResponse* job_res_res);
  private:
  const ::croupier::server::v1::TunnelJobResultResponse& _internal_job_res_res() const;
  ::croupier::server::v1::TunnelJobResultResponse* _internal_mutable_job_res_res();
  public:
  void unsafe_arena_set_allocated_job_res_res(
      ::croupier::server::v1::TunnelJobResultResponse* job_res_res);
  ::croupier::server::v1::TunnelJobResultResponse* unsafe_arena_release_job_res_res();

  // .croupier.server.v1.InvokeFrame invoke = 10;
  bool has_invoke() const;
  private:
  bool _internal_has_invoke() const;
  public:
  void clear_invoke();
  const ::croupier::server::v1::InvokeFrame& invoke() const;
  PROTOBUF_NODISCARD ::croupier::server::v1::InvokeFrame* release_invoke();
  ::croupier::server::v1::InvokeFrame* mutable_invoke();
  void set_allocated_invoke(::croupier::server::v1::InvokeFrame* invoke);
  private:
  const ::croupier::server::v1::InvokeFrame& _internal_invoke() const;
  ::croupier::server::v1::InvokeFrame* _internal_mutable_invoke();
  public:
  void unsafe_arena_set_allocated_invoke(
      ::croupier::server::v1::InvokeFrame* invoke);
  ::croupier::server::v1::InvokeFrame* unsafe_arena_release_invoke();

  // .croupier.server.v1.StartJobFrame start = 11;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::croupier::server::v1::StartJobFrame& start() const;
  PROTOBUF_NODISCARD ::croupier::server::v1::StartJobFrame* release_start();
  ::croupier::server::v1::StartJobFrame* mutable_start();
  void set_allocated_start(::croupier::server::v1::StartJobFrame* start);
  private:
  const ::croupier::server::v1::StartJobFrame& _internal_start() const;
  ::croupier::server::v1::StartJobFrame* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::croupier::server::v1::StartJobFrame* start);
  ::croupier::server::v1::StartJobFrame* unsafe_arena_release_start();

  // .croupier.server.v1.CancelJobFrame cancel = 12;
  bool has_cancel() const;
  private:
  bool _internal_has_cancel() const;
  public:
  void clear_cancel();
  const ::croupier::server::v1::CancelJobFrame& cancel() const;
  PROTOBUF_NODISCARD ::croupier::server::v1::CancelJobFrame* release_cancel();
  ::croupier::server::v1::CancelJobFrame* mutable_cancel();
  void set_allocated_cancel(::croupier::server::v1::CancelJobFrame* cancel);
  private:
  const ::croupier::server::v1::CancelJobFrame& _internal_cancel() const;
  ::croupier::server::v1::CancelJobFrame* _internal_mutable_cancel();
  public:
  void unsafe_arena_set_allocated_cancel(
      ::croupier::server::v1::CancelJobFrame* cancel);
  ::croupier::server::v1::CancelJobFrame* unsafe_arena_release_cancel();

  // @@protoc_insertion_point(class_scope:croupier.server.v1.TunnelMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::croupier::server::v1::Hello* hello_;
    ::croupier::server::v1::ResultFrame* result_;
    ::croupier::server::v1::StartJobResult* start_r_;
    ::croupier::server::v1::JobEventFrame* job_evt_;
    ::croupier::server::v1::ListLocalRequest* list_req_;
    ::croupier::server::v1::ListLocalResponse* list_res_;
    ::croupier::server::v1::TunnelJobResultRequest* job_res_req_;
    ::croupier::server::v1::TunnelJobResultResponse* job_res_res_;
    ::croupier::server::v1::InvokeFrame* invoke_;
    ::croupier::server::v1::StartJobFrame* start_;
    ::croupier::server::v1::CancelJobFrame* cancel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fserver_2fv1_2ftunnel_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Hello

// string agent_id = 1;
inline void Hello::clear_agent_id() {
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& Hello::agent_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.Hello.agent_id)
  return _internal_agent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hello::set_agent_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.Hello.agent_id)
}
inline std::string* Hello::mutable_agent_id() {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.Hello.agent_id)
  return _s;
}
inline const std::string& Hello::_internal_agent_id() const {
  return _impl_.agent_id_.Get();
}
inline void Hello::_internal_set_agent_id(const std::string& value) {
  
  _impl_.agent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Hello::_internal_mutable_agent_id() {
  
  return _impl_.agent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Hello::release_agent_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.Hello.agent_id)
  return _impl_.agent_id_.Release();
}
inline void Hello::set_allocated_agent_id(std::string* agent_id) {
  if (agent_id != nullptr) {
    
  } else {
    
  }
  _impl_.agent_id_.SetAllocated(agent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.Hello.agent_id)
}

// string game_id = 2;
inline void Hello::clear_game_id() {
  _impl_.game_id_.ClearToEmpty();
}
inline const std::string& Hello::game_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.Hello.game_id)
  return _internal_game_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hello::set_game_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.Hello.game_id)
}
inline std::string* Hello::mutable_game_id() {
  std::string* _s = _internal_mutable_game_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.Hello.game_id)
  return _s;
}
inline const std::string& Hello::_internal_game_id() const {
  return _impl_.game_id_.Get();
}
inline void Hello::_internal_set_game_id(const std::string& value) {
  
  _impl_.game_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Hello::_internal_mutable_game_id() {
  
  return _impl_.game_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Hello::release_game_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.Hello.game_id)
  return _impl_.game_id_.Release();
}
inline void Hello::set_allocated_game_id(std::string* game_id) {
  if (game_id != nullptr) {
    
  } else {
    
  }
  _impl_.game_id_.SetAllocated(game_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_id_.IsDefault()) {
    _impl_.game_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.Hello.game_id)
}

// string env = 3;
inline void Hello::clear_env() {
  _impl_.env_.ClearToEmpty();
}
inline const std::string& Hello::env() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.Hello.env)
  return _internal_env();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hello::set_env(ArgT0&& arg0, ArgT... args) {
 
 _impl_.env_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.Hello.env)
}
inline std::string* Hello::mutable_env() {
  std::string* _s = _internal_mutable_env();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.Hello.env)
  return _s;
}
inline const std::string& Hello::_internal_env() const {
  return _impl_.env_.Get();
}
inline void Hello::_internal_set_env(const std::string& value) {
  
  _impl_.env_.Set(value, GetArenaForAllocation());
}
inline std::string* Hello::_internal_mutable_env() {
  
  return _impl_.env_.Mutable(GetArenaForAllocation());
}
inline std::string* Hello::release_env() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.Hello.env)
  return _impl_.env_.Release();
}
inline void Hello::set_allocated_env(std::string* env) {
  if (env != nullptr) {
    
  } else {
    
  }
  _impl_.env_.SetAllocated(env, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.env_.IsDefault()) {
    _impl_.env_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.Hello.env)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InvokeFrame

// string request_id = 1;
inline void InvokeFrame::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& InvokeFrame::request_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.InvokeFrame.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeFrame::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.InvokeFrame.request_id)
}
inline std::string* InvokeFrame::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.InvokeFrame.request_id)
  return _s;
}
inline const std::string& InvokeFrame::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void InvokeFrame::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeFrame::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeFrame::release_request_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.InvokeFrame.request_id)
  return _impl_.request_id_.Release();
}
inline void InvokeFrame::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.InvokeFrame.request_id)
}

// string function_id = 2;
inline void InvokeFrame::clear_function_id() {
  _impl_.function_id_.ClearToEmpty();
}
inline const std::string& InvokeFrame::function_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.InvokeFrame.function_id)
  return _internal_function_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeFrame::set_function_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.function_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.InvokeFrame.function_id)
}
inline std::string* InvokeFrame::mutable_function_id() {
  std::string* _s = _internal_mutable_function_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.InvokeFrame.function_id)
  return _s;
}
inline const std::string& InvokeFrame::_internal_function_id() const {
  return _impl_.function_id_.Get();
}
inline void InvokeFrame::_internal_set_function_id(const std::string& value) {
  
  _impl_.function_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeFrame::_internal_mutable_function_id() {
  
  return _impl_.function_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeFrame::release_function_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.InvokeFrame.function_id)
  return _impl_.function_id_.Release();
}
inline void InvokeFrame::set_allocated_function_id(std::string* function_id) {
  if (function_id != nullptr) {
    
  } else {
    
  }
  _impl_.function_id_.SetAllocated(function_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_id_.IsDefault()) {
    _impl_.function_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.InvokeFrame.function_id)
}

// string idempotency_key = 3;
inline void InvokeFrame::clear_idempotency_key() {
  _impl_.idempotency_key_.ClearToEmpty();
}
inline const std::string& InvokeFrame::idempotency_key() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.InvokeFrame.idempotency_key)
  return _internal_idempotency_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeFrame::set_idempotency_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.idempotency_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.InvokeFrame.idempotency_key)
}
inline std::string* InvokeFrame::mutable_idempotency_key() {
  std::string* _s = _internal_mutable_idempotency_key();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.InvokeFrame.idempotency_key)
  return _s;
}
inline const std::string& InvokeFrame::_internal_idempotency_key() const {
  return _impl_.idempotency_key_.Get();
}
inline void InvokeFrame::_internal_set_idempotency_key(const std::string& value) {
  
  _impl_.idempotency_key_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeFrame::_internal_mutable_idempotency_key() {
  
  return _impl_.idempotency_key_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeFrame::release_idempotency_key() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.InvokeFrame.idempotency_key)
  return _impl_.idempotency_key_.Release();
}
inline void InvokeFrame::set_allocated_idempotency_key(std::string* idempotency_key) {
  if (idempotency_key != nullptr) {
    
  } else {
    
  }
  _impl_.idempotency_key_.SetAllocated(idempotency_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.idempotency_key_.IsDefault()) {
    _impl_.idempotency_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.InvokeFrame.idempotency_key)
}

// bytes payload = 4;
inline void InvokeFrame::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& InvokeFrame::payload() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.InvokeFrame.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeFrame::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.InvokeFrame.payload)
}
inline std::string* InvokeFrame::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.InvokeFrame.payload)
  return _s;
}
inline const std::string& InvokeFrame::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void InvokeFrame::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeFrame::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeFrame::release_payload() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.InvokeFrame.payload)
  return _impl_.payload_.Release();
}
inline void InvokeFrame::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.InvokeFrame.payload)
}

// map<string, string> metadata = 5;
inline int InvokeFrame::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int InvokeFrame::metadata_size() const {
  return _internal_metadata_size();
}
inline void InvokeFrame::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InvokeFrame::_internal_metadata() const {
  return _impl_.metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InvokeFrame::metadata() const {
  // @@protoc_insertion_point(field_map:croupier.server.v1.InvokeFrame.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InvokeFrame::_internal_mutable_metadata() {
  return _impl_.metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InvokeFrame::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:croupier.server.v1.InvokeFrame.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StartJobFrame

// string request_id = 1;
inline void StartJobFrame::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& StartJobFrame::request_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.StartJobFrame.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartJobFrame::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.StartJobFrame.request_id)
}
inline std::string* StartJobFrame::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.StartJobFrame.request_id)
  return _s;
}
inline const std::string& StartJobFrame::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void StartJobFrame::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StartJobFrame::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StartJobFrame::release_request_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.StartJobFrame.request_id)
  return _impl_.request_id_.Release();
}
inline void StartJobFrame::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.StartJobFrame.request_id)
}

// string function_id = 2;
inline void StartJobFrame::clear_function_id() {
  _impl_.function_id_.ClearToEmpty();
}
inline const std::string& StartJobFrame::function_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.StartJobFrame.function_id)
  return _internal_function_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartJobFrame::set_function_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.function_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.StartJobFrame.function_id)
}
inline std::string* StartJobFrame::mutable_function_id() {
  std::string* _s = _internal_mutable_function_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.StartJobFrame.function_id)
  return _s;
}
inline const std::string& StartJobFrame::_internal_function_id() const {
  return _impl_.function_id_.Get();
}
inline void StartJobFrame::_internal_set_function_id(const std::string& value) {
  
  _impl_.function_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StartJobFrame::_internal_mutable_function_id() {
  
  return _impl_.function_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StartJobFrame::release_function_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.StartJobFrame.function_id)
  return _impl_.function_id_.Release();
}
inline void StartJobFrame::set_allocated_function_id(std::string* function_id) {
  if (function_id != nullptr) {
    
  } else {
    
  }
  _impl_.function_id_.SetAllocated(function_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_id_.IsDefault()) {
    _impl_.function_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.StartJobFrame.function_id)
}

// string idempotency_key = 3;
inline void StartJobFrame::clear_idempotency_key() {
  _impl_.idempotency_key_.ClearToEmpty();
}
inline const std::string& StartJobFrame::idempotency_key() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.StartJobFrame.idempotency_key)
  return _internal_idempotency_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartJobFrame::set_idempotency_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.idempotency_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.StartJobFrame.idempotency_key)
}
inline std::string* StartJobFrame::mutable_idempotency_key() {
  std::string* _s = _internal_mutable_idempotency_key();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.StartJobFrame.idempotency_key)
  return _s;
}
inline const std::string& StartJobFrame::_internal_idempotency_key() const {
  return _impl_.idempotency_key_.Get();
}
inline void StartJobFrame::_internal_set_idempotency_key(const std::string& value) {
  
  _impl_.idempotency_key_.Set(value, GetArenaForAllocation());
}
inline std::string* StartJobFrame::_internal_mutable_idempotency_key() {
  
  return _impl_.idempotency_key_.Mutable(GetArenaForAllocation());
}
inline std::string* StartJobFrame::release_idempotency_key() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.StartJobFrame.idempotency_key)
  return _impl_.idempotency_key_.Release();
}
inline void StartJobFrame::set_allocated_idempotency_key(std::string* idempotency_key) {
  if (idempotency_key != nullptr) {
    
  } else {
    
  }
  _impl_.idempotency_key_.SetAllocated(idempotency_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.idempotency_key_.IsDefault()) {
    _impl_.idempotency_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.StartJobFrame.idempotency_key)
}

// bytes payload = 4;
inline void StartJobFrame::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& StartJobFrame::payload() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.StartJobFrame.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartJobFrame::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.StartJobFrame.payload)
}
inline std::string* StartJobFrame::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.StartJobFrame.payload)
  return _s;
}
inline const std::string& StartJobFrame::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void StartJobFrame::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* StartJobFrame::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* StartJobFrame::release_payload() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.StartJobFrame.payload)
  return _impl_.payload_.Release();
}
inline void StartJobFrame::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.StartJobFrame.payload)
}

// map<string, string> metadata = 5;
inline int StartJobFrame::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int StartJobFrame::metadata_size() const {
  return _internal_metadata_size();
}
inline void StartJobFrame::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StartJobFrame::_internal_metadata() const {
  return _impl_.metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StartJobFrame::metadata() const {
  // @@protoc_insertion_point(field_map:croupier.server.v1.StartJobFrame.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StartJobFrame::_internal_mutable_metadata() {
  return _impl_.metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StartJobFrame::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:croupier.server.v1.StartJobFrame.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// CancelJobFrame

// string job_id = 1;
inline void CancelJobFrame::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& CancelJobFrame::job_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.CancelJobFrame.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelJobFrame::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.CancelJobFrame.job_id)
}
inline std::string* CancelJobFrame::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.CancelJobFrame.job_id)
  return _s;
}
inline const std::string& CancelJobFrame::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void CancelJobFrame::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelJobFrame::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelJobFrame::release_job_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.CancelJobFrame.job_id)
  return _impl_.job_id_.Release();
}
inline void CancelJobFrame::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.CancelJobFrame.job_id)
}

// -------------------------------------------------------------------

// ResultFrame

// string request_id = 1;
inline void ResultFrame::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& ResultFrame::request_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.ResultFrame.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResultFrame::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.ResultFrame.request_id)
}
inline std::string* ResultFrame::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.ResultFrame.request_id)
  return _s;
}
inline const std::string& ResultFrame::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void ResultFrame::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResultFrame::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResultFrame::release_request_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.ResultFrame.request_id)
  return _impl_.request_id_.Release();
}
inline void ResultFrame::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.ResultFrame.request_id)
}

// bytes payload = 2;
inline void ResultFrame::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& ResultFrame::payload() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.ResultFrame.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResultFrame::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.ResultFrame.payload)
}
inline std::string* ResultFrame::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.ResultFrame.payload)
  return _s;
}
inline const std::string& ResultFrame::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void ResultFrame::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* ResultFrame::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* ResultFrame::release_payload() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.ResultFrame.payload)
  return _impl_.payload_.Release();
}
inline void ResultFrame::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.ResultFrame.payload)
}

// string error = 3;
inline void ResultFrame::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& ResultFrame::error() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.ResultFrame.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResultFrame::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.ResultFrame.error)
}
inline std::string* ResultFrame::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.ResultFrame.error)
  return _s;
}
inline const std::string& ResultFrame::_internal_error() const {
  return _impl_.error_.Get();
}
inline void ResultFrame::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* ResultFrame::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* ResultFrame::release_error() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.ResultFrame.error)
  return _impl_.error_.Release();
}
inline void ResultFrame::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.ResultFrame.error)
}

// -------------------------------------------------------------------

// StartJobResult

// string request_id = 1;
inline void StartJobResult::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& StartJobResult::request_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.StartJobResult.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartJobResult::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.StartJobResult.request_id)
}
inline std::string* StartJobResult::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.StartJobResult.request_id)
  return _s;
}
inline const std::string& StartJobResult::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void StartJobResult::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StartJobResult::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StartJobResult::release_request_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.StartJobResult.request_id)
  return _impl_.request_id_.Release();
}
inline void StartJobResult::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.StartJobResult.request_id)
}

// string job_id = 2;
inline void StartJobResult::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& StartJobResult::job_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.StartJobResult.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartJobResult::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.StartJobResult.job_id)
}
inline std::string* StartJobResult::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.StartJobResult.job_id)
  return _s;
}
inline const std::string& StartJobResult::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void StartJobResult::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StartJobResult::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StartJobResult::release_job_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.StartJobResult.job_id)
  return _impl_.job_id_.Release();
}
inline void StartJobResult::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.StartJobResult.job_id)
}

// string error = 3;
inline void StartJobResult::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& StartJobResult::error() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.StartJobResult.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartJobResult::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.StartJobResult.error)
}
inline std::string* StartJobResult::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.StartJobResult.error)
  return _s;
}
inline const std::string& StartJobResult::_internal_error() const {
  return _impl_.error_.Get();
}
inline void StartJobResult::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* StartJobResult::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* StartJobResult::release_error() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.StartJobResult.error)
  return _impl_.error_.Release();
}
inline void StartJobResult::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.StartJobResult.error)
}

// -------------------------------------------------------------------

// JobEventFrame

// string job_id = 1;
inline void JobEventFrame::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& JobEventFrame::job_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.JobEventFrame.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobEventFrame::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.JobEventFrame.job_id)
}
inline std::string* JobEventFrame::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.JobEventFrame.job_id)
  return _s;
}
inline const std::string& JobEventFrame::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void JobEventFrame::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobEventFrame::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobEventFrame::release_job_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.JobEventFrame.job_id)
  return _impl_.job_id_.Release();
}
inline void JobEventFrame::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.JobEventFrame.job_id)
}

// string type = 2;
inline void JobEventFrame::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& JobEventFrame::type() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.JobEventFrame.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobEventFrame::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.JobEventFrame.type)
}
inline std::string* JobEventFrame::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.JobEventFrame.type)
  return _s;
}
inline const std::string& JobEventFrame::_internal_type() const {
  return _impl_.type_.Get();
}
inline void JobEventFrame::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* JobEventFrame::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* JobEventFrame::release_type() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.JobEventFrame.type)
  return _impl_.type_.Release();
}
inline void JobEventFrame::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.JobEventFrame.type)
}

// string message = 3;
inline void JobEventFrame::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& JobEventFrame::message() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.JobEventFrame.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobEventFrame::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.JobEventFrame.message)
}
inline std::string* JobEventFrame::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.JobEventFrame.message)
  return _s;
}
inline const std::string& JobEventFrame::_internal_message() const {
  return _impl_.message_.Get();
}
inline void JobEventFrame::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* JobEventFrame::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* JobEventFrame::release_message() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.JobEventFrame.message)
  return _impl_.message_.Release();
}
inline void JobEventFrame::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.JobEventFrame.message)
}

// int32 progress = 4;
inline void JobEventFrame::clear_progress() {
  _impl_.progress_ = 0;
}
inline int32_t JobEventFrame::_internal_progress() const {
  return _impl_.progress_;
}
inline int32_t JobEventFrame::progress() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.JobEventFrame.progress)
  return _internal_progress();
}
inline void JobEventFrame::_internal_set_progress(int32_t value) {
  
  _impl_.progress_ = value;
}
inline void JobEventFrame::set_progress(int32_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:croupier.server.v1.JobEventFrame.progress)
}

// bytes payload = 5;
inline void JobEventFrame::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& JobEventFrame::payload() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.JobEventFrame.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobEventFrame::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.JobEventFrame.payload)
}
inline std::string* JobEventFrame::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.JobEventFrame.payload)
  return _s;
}
inline const std::string& JobEventFrame::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void JobEventFrame::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* JobEventFrame::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* JobEventFrame::release_payload() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.JobEventFrame.payload)
  return _impl_.payload_.Release();
}
inline void JobEventFrame::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.JobEventFrame.payload)
}

// -------------------------------------------------------------------

// ListLocalRequest

// string request_id = 1;
inline void ListLocalRequest::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& ListLocalRequest::request_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.ListLocalRequest.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListLocalRequest::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.ListLocalRequest.request_id)
}
inline std::string* ListLocalRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.ListLocalRequest.request_id)
  return _s;
}
inline const std::string& ListLocalRequest::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void ListLocalRequest::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListLocalRequest::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListLocalRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.ListLocalRequest.request_id)
  return _impl_.request_id_.Release();
}
inline void ListLocalRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.ListLocalRequest.request_id)
}

// string function_id = 2;
inline void ListLocalRequest::clear_function_id() {
  _impl_.function_id_.ClearToEmpty();
}
inline const std::string& ListLocalRequest::function_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.ListLocalRequest.function_id)
  return _internal_function_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListLocalRequest::set_function_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.function_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.ListLocalRequest.function_id)
}
inline std::string* ListLocalRequest::mutable_function_id() {
  std::string* _s = _internal_mutable_function_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.ListLocalRequest.function_id)
  return _s;
}
inline const std::string& ListLocalRequest::_internal_function_id() const {
  return _impl_.function_id_.Get();
}
inline void ListLocalRequest::_internal_set_function_id(const std::string& value) {
  
  _impl_.function_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListLocalRequest::_internal_mutable_function_id() {
  
  return _impl_.function_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListLocalRequest::release_function_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.ListLocalRequest.function_id)
  return _impl_.function_id_.Release();
}
inline void ListLocalRequest::set_allocated_function_id(std::string* function_id) {
  if (function_id != nullptr) {
    
  } else {
    
  }
  _impl_.function_id_.SetAllocated(function_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_id_.IsDefault()) {
    _impl_.function_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.ListLocalRequest.function_id)
}

// -------------------------------------------------------------------

// ListLocalResponse

// string request_id = 1;
inline void ListLocalResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& ListLocalResponse::request_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.ListLocalResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListLocalResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.ListLocalResponse.request_id)
}
inline std::string* ListLocalResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.ListLocalResponse.request_id)
  return _s;
}
inline const std::string& ListLocalResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void ListLocalResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListLocalResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListLocalResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.ListLocalResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void ListLocalResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.ListLocalResponse.request_id)
}

// string function_id = 2;
inline void ListLocalResponse::clear_function_id() {
  _impl_.function_id_.ClearToEmpty();
}
inline const std::string& ListLocalResponse::function_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.ListLocalResponse.function_id)
  return _internal_function_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListLocalResponse::set_function_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.function_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.ListLocalResponse.function_id)
}
inline std::string* ListLocalResponse::mutable_function_id() {
  std::string* _s = _internal_mutable_function_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.ListLocalResponse.function_id)
  return _s;
}
inline const std::string& ListLocalResponse::_internal_function_id() const {
  return _impl_.function_id_.Get();
}
inline void ListLocalResponse::_internal_set_function_id(const std::string& value) {
  
  _impl_.function_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListLocalResponse::_internal_mutable_function_id() {
  
  return _impl_.function_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListLocalResponse::release_function_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.ListLocalResponse.function_id)
  return _impl_.function_id_.Release();
}
inline void ListLocalResponse::set_allocated_function_id(std::string* function_id) {
  if (function_id != nullptr) {
    
  } else {
    
  }
  _impl_.function_id_.SetAllocated(function_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_id_.IsDefault()) {
    _impl_.function_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.ListLocalResponse.function_id)
}

// repeated string service_ids = 3;
inline int ListLocalResponse::_internal_service_ids_size() const {
  return _impl_.service_ids_.size();
}
inline int ListLocalResponse::service_ids_size() const {
  return _internal_service_ids_size();
}
inline void ListLocalResponse::clear_service_ids() {
  _impl_.service_ids_.Clear();
}
inline std::string* ListLocalResponse::add_service_ids() {
  std::string* _s = _internal_add_service_ids();
  // @@protoc_insertion_point(field_add_mutable:croupier.server.v1.ListLocalResponse.service_ids)
  return _s;
}
inline const std::string& ListLocalResponse::_internal_service_ids(int index) const {
  return _impl_.service_ids_.Get(index);
}
inline const std::string& ListLocalResponse::service_ids(int index) const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.ListLocalResponse.service_ids)
  return _internal_service_ids(index);
}
inline std::string* ListLocalResponse::mutable_service_ids(int index) {
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.ListLocalResponse.service_ids)
  return _impl_.service_ids_.Mutable(index);
}
inline void ListLocalResponse::set_service_ids(int index, const std::string& value) {
  _impl_.service_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:croupier.server.v1.ListLocalResponse.service_ids)
}
inline void ListLocalResponse::set_service_ids(int index, std::string&& value) {
  _impl_.service_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:croupier.server.v1.ListLocalResponse.service_ids)
}
inline void ListLocalResponse::set_service_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.service_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:croupier.server.v1.ListLocalResponse.service_ids)
}
inline void ListLocalResponse::set_service_ids(int index, const char* value, size_t size) {
  _impl_.service_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:croupier.server.v1.ListLocalResponse.service_ids)
}
inline std::string* ListLocalResponse::_internal_add_service_ids() {
  return _impl_.service_ids_.Add();
}
inline void ListLocalResponse::add_service_ids(const std::string& value) {
  _impl_.service_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:croupier.server.v1.ListLocalResponse.service_ids)
}
inline void ListLocalResponse::add_service_ids(std::string&& value) {
  _impl_.service_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:croupier.server.v1.ListLocalResponse.service_ids)
}
inline void ListLocalResponse::add_service_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.service_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:croupier.server.v1.ListLocalResponse.service_ids)
}
inline void ListLocalResponse::add_service_ids(const char* value, size_t size) {
  _impl_.service_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:croupier.server.v1.ListLocalResponse.service_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListLocalResponse::service_ids() const {
  // @@protoc_insertion_point(field_list:croupier.server.v1.ListLocalResponse.service_ids)
  return _impl_.service_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListLocalResponse::mutable_service_ids() {
  // @@protoc_insertion_point(field_mutable_list:croupier.server.v1.ListLocalResponse.service_ids)
  return &_impl_.service_ids_;
}

// string error = 4;
inline void ListLocalResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& ListLocalResponse::error() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.ListLocalResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListLocalResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.ListLocalResponse.error)
}
inline std::string* ListLocalResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.ListLocalResponse.error)
  return _s;
}
inline const std::string& ListLocalResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void ListLocalResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* ListLocalResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* ListLocalResponse::release_error() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.ListLocalResponse.error)
  return _impl_.error_.Release();
}
inline void ListLocalResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.ListLocalResponse.error)
}

// -------------------------------------------------------------------

// TunnelJobResultRequest

// string request_id = 1;
inline void TunnelJobResultRequest::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& TunnelJobResultRequest::request_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelJobResultRequest.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TunnelJobResultRequest::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.TunnelJobResultRequest.request_id)
}
inline std::string* TunnelJobResultRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelJobResultRequest.request_id)
  return _s;
}
inline const std::string& TunnelJobResultRequest::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void TunnelJobResultRequest::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelJobResultRequest::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TunnelJobResultRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelJobResultRequest.request_id)
  return _impl_.request_id_.Release();
}
inline void TunnelJobResultRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelJobResultRequest.request_id)
}

// string job_id = 2;
inline void TunnelJobResultRequest::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& TunnelJobResultRequest::job_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelJobResultRequest.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TunnelJobResultRequest::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.TunnelJobResultRequest.job_id)
}
inline std::string* TunnelJobResultRequest::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelJobResultRequest.job_id)
  return _s;
}
inline const std::string& TunnelJobResultRequest::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void TunnelJobResultRequest::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelJobResultRequest::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TunnelJobResultRequest::release_job_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelJobResultRequest.job_id)
  return _impl_.job_id_.Release();
}
inline void TunnelJobResultRequest::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelJobResultRequest.job_id)
}

// -------------------------------------------------------------------

// TunnelJobResultResponse

// string request_id = 1;
inline void TunnelJobResultResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& TunnelJobResultResponse::request_id() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelJobResultResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TunnelJobResultResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.TunnelJobResultResponse.request_id)
}
inline std::string* TunnelJobResultResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelJobResultResponse.request_id)
  return _s;
}
inline const std::string& TunnelJobResultResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void TunnelJobResultResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelJobResultResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TunnelJobResultResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelJobResultResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void TunnelJobResultResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelJobResultResponse.request_id)
}

// string state = 2;
inline void TunnelJobResultResponse::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& TunnelJobResultResponse::state() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelJobResultResponse.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TunnelJobResultResponse::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.TunnelJobResultResponse.state)
}
inline std::string* TunnelJobResultResponse::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelJobResultResponse.state)
  return _s;
}
inline const std::string& TunnelJobResultResponse::_internal_state() const {
  return _impl_.state_.Get();
}
inline void TunnelJobResultResponse::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelJobResultResponse::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* TunnelJobResultResponse::release_state() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelJobResultResponse.state)
  return _impl_.state_.Release();
}
inline void TunnelJobResultResponse::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelJobResultResponse.state)
}

// bytes payload = 3;
inline void TunnelJobResultResponse::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& TunnelJobResultResponse::payload() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelJobResultResponse.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TunnelJobResultResponse::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.TunnelJobResultResponse.payload)
}
inline std::string* TunnelJobResultResponse::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelJobResultResponse.payload)
  return _s;
}
inline const std::string& TunnelJobResultResponse::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void TunnelJobResultResponse::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelJobResultResponse::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* TunnelJobResultResponse::release_payload() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelJobResultResponse.payload)
  return _impl_.payload_.Release();
}
inline void TunnelJobResultResponse::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelJobResultResponse.payload)
}

// string error = 4;
inline void TunnelJobResultResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& TunnelJobResultResponse::error() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelJobResultResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TunnelJobResultResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.TunnelJobResultResponse.error)
}
inline std::string* TunnelJobResultResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelJobResultResponse.error)
  return _s;
}
inline const std::string& TunnelJobResultResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void TunnelJobResultResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelJobResultResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* TunnelJobResultResponse::release_error() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelJobResultResponse.error)
  return _impl_.error_.Release();
}
inline void TunnelJobResultResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelJobResultResponse.error)
}

// -------------------------------------------------------------------

// TunnelMessage

// string type = 1;
inline void TunnelMessage::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& TunnelMessage::type() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TunnelMessage::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:croupier.server.v1.TunnelMessage.type)
}
inline std::string* TunnelMessage::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.type)
  return _s;
}
inline const std::string& TunnelMessage::_internal_type() const {
  return _impl_.type_.Get();
}
inline void TunnelMessage::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelMessage::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* TunnelMessage::release_type() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.type)
  return _impl_.type_.Release();
}
inline void TunnelMessage::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.type)
}

// .croupier.server.v1.Hello hello = 2;
inline bool TunnelMessage::_internal_has_hello() const {
  return this != internal_default_instance() && _impl_.hello_ != nullptr;
}
inline bool TunnelMessage::has_hello() const {
  return _internal_has_hello();
}
inline void TunnelMessage::clear_hello() {
  if (GetArenaForAllocation() == nullptr && _impl_.hello_ != nullptr) {
    delete _impl_.hello_;
  }
  _impl_.hello_ = nullptr;
}
inline const ::croupier::server::v1::Hello& TunnelMessage::_internal_hello() const {
  const ::croupier::server::v1::Hello* p = _impl_.hello_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::server::v1::Hello&>(
      ::croupier::server::v1::_Hello_default_instance_);
}
inline const ::croupier::server::v1::Hello& TunnelMessage::hello() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.hello)
  return _internal_hello();
}
inline void TunnelMessage::unsafe_arena_set_allocated_hello(
    ::croupier::server::v1::Hello* hello) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hello_);
  }
  _impl_.hello_ = hello;
  if (hello) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.server.v1.TunnelMessage.hello)
}
inline ::croupier::server::v1::Hello* TunnelMessage::release_hello() {
  
  ::croupier::server::v1::Hello* temp = _impl_.hello_;
  _impl_.hello_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::croupier::server::v1::Hello* TunnelMessage::unsafe_arena_release_hello() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.hello)
  
  ::croupier::server::v1::Hello* temp = _impl_.hello_;
  _impl_.hello_ = nullptr;
  return temp;
}
inline ::croupier::server::v1::Hello* TunnelMessage::_internal_mutable_hello() {
  
  if (_impl_.hello_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::server::v1::Hello>(GetArenaForAllocation());
    _impl_.hello_ = p;
  }
  return _impl_.hello_;
}
inline ::croupier::server::v1::Hello* TunnelMessage::mutable_hello() {
  ::croupier::server::v1::Hello* _msg = _internal_mutable_hello();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.hello)
  return _msg;
}
inline void TunnelMessage::set_allocated_hello(::croupier::server::v1::Hello* hello) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hello_;
  }
  if (hello) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hello);
    if (message_arena != submessage_arena) {
      hello = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hello, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hello_ = hello;
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.hello)
}

// .croupier.server.v1.ResultFrame result = 3;
inline bool TunnelMessage::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool TunnelMessage::has_result() const {
  return _internal_has_result();
}
inline void TunnelMessage::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::croupier::server::v1::ResultFrame& TunnelMessage::_internal_result() const {
  const ::croupier::server::v1::ResultFrame* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::server::v1::ResultFrame&>(
      ::croupier::server::v1::_ResultFrame_default_instance_);
}
inline const ::croupier::server::v1::ResultFrame& TunnelMessage::result() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.result)
  return _internal_result();
}
inline void TunnelMessage::unsafe_arena_set_allocated_result(
    ::croupier::server::v1::ResultFrame* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.server.v1.TunnelMessage.result)
}
inline ::croupier::server::v1::ResultFrame* TunnelMessage::release_result() {
  
  ::croupier::server::v1::ResultFrame* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::croupier::server::v1::ResultFrame* TunnelMessage::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.result)
  
  ::croupier::server::v1::ResultFrame* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::croupier::server::v1::ResultFrame* TunnelMessage::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::server::v1::ResultFrame>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::croupier::server::v1::ResultFrame* TunnelMessage::mutable_result() {
  ::croupier::server::v1::ResultFrame* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.result)
  return _msg;
}
inline void TunnelMessage::set_allocated_result(::croupier::server::v1::ResultFrame* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.result)
}

// .croupier.server.v1.StartJobResult start_r = 4;
inline bool TunnelMessage::_internal_has_start_r() const {
  return this != internal_default_instance() && _impl_.start_r_ != nullptr;
}
inline bool TunnelMessage::has_start_r() const {
  return _internal_has_start_r();
}
inline void TunnelMessage::clear_start_r() {
  if (GetArenaForAllocation() == nullptr && _impl_.start_r_ != nullptr) {
    delete _impl_.start_r_;
  }
  _impl_.start_r_ = nullptr;
}
inline const ::croupier::server::v1::StartJobResult& TunnelMessage::_internal_start_r() const {
  const ::croupier::server::v1::StartJobResult* p = _impl_.start_r_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::server::v1::StartJobResult&>(
      ::croupier::server::v1::_StartJobResult_default_instance_);
}
inline const ::croupier::server::v1::StartJobResult& TunnelMessage::start_r() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.start_r)
  return _internal_start_r();
}
inline void TunnelMessage::unsafe_arena_set_allocated_start_r(
    ::croupier::server::v1::StartJobResult* start_r) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_r_);
  }
  _impl_.start_r_ = start_r;
  if (start_r) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.server.v1.TunnelMessage.start_r)
}
inline ::croupier::server::v1::StartJobResult* TunnelMessage::release_start_r() {
  
  ::croupier::server::v1::StartJobResult* temp = _impl_.start_r_;
  _impl_.start_r_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::croupier::server::v1::StartJobResult* TunnelMessage::unsafe_arena_release_start_r() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.start_r)
  
  ::croupier::server::v1::StartJobResult* temp = _impl_.start_r_;
  _impl_.start_r_ = nullptr;
  return temp;
}
inline ::croupier::server::v1::StartJobResult* TunnelMessage::_internal_mutable_start_r() {
  
  if (_impl_.start_r_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::server::v1::StartJobResult>(GetArenaForAllocation());
    _impl_.start_r_ = p;
  }
  return _impl_.start_r_;
}
inline ::croupier::server::v1::StartJobResult* TunnelMessage::mutable_start_r() {
  ::croupier::server::v1::StartJobResult* _msg = _internal_mutable_start_r();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.start_r)
  return _msg;
}
inline void TunnelMessage::set_allocated_start_r(::croupier::server::v1::StartJobResult* start_r) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_r_;
  }
  if (start_r) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start_r);
    if (message_arena != submessage_arena) {
      start_r = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_r, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_r_ = start_r;
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.start_r)
}

// .croupier.server.v1.JobEventFrame job_evt = 5;
inline bool TunnelMessage::_internal_has_job_evt() const {
  return this != internal_default_instance() && _impl_.job_evt_ != nullptr;
}
inline bool TunnelMessage::has_job_evt() const {
  return _internal_has_job_evt();
}
inline void TunnelMessage::clear_job_evt() {
  if (GetArenaForAllocation() == nullptr && _impl_.job_evt_ != nullptr) {
    delete _impl_.job_evt_;
  }
  _impl_.job_evt_ = nullptr;
}
inline const ::croupier::server::v1::JobEventFrame& TunnelMessage::_internal_job_evt() const {
  const ::croupier::server::v1::JobEventFrame* p = _impl_.job_evt_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::server::v1::JobEventFrame&>(
      ::croupier::server::v1::_JobEventFrame_default_instance_);
}
inline const ::croupier::server::v1::JobEventFrame& TunnelMessage::job_evt() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.job_evt)
  return _internal_job_evt();
}
inline void TunnelMessage::unsafe_arena_set_allocated_job_evt(
    ::croupier::server::v1::JobEventFrame* job_evt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.job_evt_);
  }
  _impl_.job_evt_ = job_evt;
  if (job_evt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.server.v1.TunnelMessage.job_evt)
}
inline ::croupier::server::v1::JobEventFrame* TunnelMessage::release_job_evt() {
  
  ::croupier::server::v1::JobEventFrame* temp = _impl_.job_evt_;
  _impl_.job_evt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::croupier::server::v1::JobEventFrame* TunnelMessage::unsafe_arena_release_job_evt() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.job_evt)
  
  ::croupier::server::v1::JobEventFrame* temp = _impl_.job_evt_;
  _impl_.job_evt_ = nullptr;
  return temp;
}
inline ::croupier::server::v1::JobEventFrame* TunnelMessage::_internal_mutable_job_evt() {
  
  if (_impl_.job_evt_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::server::v1::JobEventFrame>(GetArenaForAllocation());
    _impl_.job_evt_ = p;
  }
  return _impl_.job_evt_;
}
inline ::croupier::server::v1::JobEventFrame* TunnelMessage::mutable_job_evt() {
  ::croupier::server::v1::JobEventFrame* _msg = _internal_mutable_job_evt();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.job_evt)
  return _msg;
}
inline void TunnelMessage::set_allocated_job_evt(::croupier::server::v1::JobEventFrame* job_evt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.job_evt_;
  }
  if (job_evt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(job_evt);
    if (message_arena != submessage_arena) {
      job_evt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job_evt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.job_evt_ = job_evt;
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.job_evt)
}

// .croupier.server.v1.ListLocalRequest list_req = 6;
inline bool TunnelMessage::_internal_has_list_req() const {
  return this != internal_default_instance() && _impl_.list_req_ != nullptr;
}
inline bool TunnelMessage::has_list_req() const {
  return _internal_has_list_req();
}
inline void TunnelMessage::clear_list_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.list_req_ != nullptr) {
    delete _impl_.list_req_;
  }
  _impl_.list_req_ = nullptr;
}
inline const ::croupier::server::v1::ListLocalRequest& TunnelMessage::_internal_list_req() const {
  const ::croupier::server::v1::ListLocalRequest* p = _impl_.list_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::server::v1::ListLocalRequest&>(
      ::croupier::server::v1::_ListLocalRequest_default_instance_);
}
inline const ::croupier::server::v1::ListLocalRequest& TunnelMessage::list_req() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.list_req)
  return _internal_list_req();
}
inline void TunnelMessage::unsafe_arena_set_allocated_list_req(
    ::croupier::server::v1::ListLocalRequest* list_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_req_);
  }
  _impl_.list_req_ = list_req;
  if (list_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.server.v1.TunnelMessage.list_req)
}
inline ::croupier::server::v1::ListLocalRequest* TunnelMessage::release_list_req() {
  
  ::croupier::server::v1::ListLocalRequest* temp = _impl_.list_req_;
  _impl_.list_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::croupier::server::v1::ListLocalRequest* TunnelMessage::unsafe_arena_release_list_req() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.list_req)
  
  ::croupier::server::v1::ListLocalRequest* temp = _impl_.list_req_;
  _impl_.list_req_ = nullptr;
  return temp;
}
inline ::croupier::server::v1::ListLocalRequest* TunnelMessage::_internal_mutable_list_req() {
  
  if (_impl_.list_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::server::v1::ListLocalRequest>(GetArenaForAllocation());
    _impl_.list_req_ = p;
  }
  return _impl_.list_req_;
}
inline ::croupier::server::v1::ListLocalRequest* TunnelMessage::mutable_list_req() {
  ::croupier::server::v1::ListLocalRequest* _msg = _internal_mutable_list_req();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.list_req)
  return _msg;
}
inline void TunnelMessage::set_allocated_list_req(::croupier::server::v1::ListLocalRequest* list_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.list_req_;
  }
  if (list_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(list_req);
    if (message_arena != submessage_arena) {
      list_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.list_req_ = list_req;
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.list_req)
}

// .croupier.server.v1.ListLocalResponse list_res = 7;
inline bool TunnelMessage::_internal_has_list_res() const {
  return this != internal_default_instance() && _impl_.list_res_ != nullptr;
}
inline bool TunnelMessage::has_list_res() const {
  return _internal_has_list_res();
}
inline void TunnelMessage::clear_list_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.list_res_ != nullptr) {
    delete _impl_.list_res_;
  }
  _impl_.list_res_ = nullptr;
}
inline const ::croupier::server::v1::ListLocalResponse& TunnelMessage::_internal_list_res() const {
  const ::croupier::server::v1::ListLocalResponse* p = _impl_.list_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::server::v1::ListLocalResponse&>(
      ::croupier::server::v1::_ListLocalResponse_default_instance_);
}
inline const ::croupier::server::v1::ListLocalResponse& TunnelMessage::list_res() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.list_res)
  return _internal_list_res();
}
inline void TunnelMessage::unsafe_arena_set_allocated_list_res(
    ::croupier::server::v1::ListLocalResponse* list_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_res_);
  }
  _impl_.list_res_ = list_res;
  if (list_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.server.v1.TunnelMessage.list_res)
}
inline ::croupier::server::v1::ListLocalResponse* TunnelMessage::release_list_res() {
  
  ::croupier::server::v1::ListLocalResponse* temp = _impl_.list_res_;
  _impl_.list_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::croupier::server::v1::ListLocalResponse* TunnelMessage::unsafe_arena_release_list_res() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.list_res)
  
  ::croupier::server::v1::ListLocalResponse* temp = _impl_.list_res_;
  _impl_.list_res_ = nullptr;
  return temp;
}
inline ::croupier::server::v1::ListLocalResponse* TunnelMessage::_internal_mutable_list_res() {
  
  if (_impl_.list_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::server::v1::ListLocalResponse>(GetArenaForAllocation());
    _impl_.list_res_ = p;
  }
  return _impl_.list_res_;
}
inline ::croupier::server::v1::ListLocalResponse* TunnelMessage::mutable_list_res() {
  ::croupier::server::v1::ListLocalResponse* _msg = _internal_mutable_list_res();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.list_res)
  return _msg;
}
inline void TunnelMessage::set_allocated_list_res(::croupier::server::v1::ListLocalResponse* list_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.list_res_;
  }
  if (list_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(list_res);
    if (message_arena != submessage_arena) {
      list_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.list_res_ = list_res;
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.list_res)
}

// .croupier.server.v1.TunnelJobResultRequest job_res_req = 8;
inline bool TunnelMessage::_internal_has_job_res_req() const {
  return this != internal_default_instance() && _impl_.job_res_req_ != nullptr;
}
inline bool TunnelMessage::has_job_res_req() const {
  return _internal_has_job_res_req();
}
inline void TunnelMessage::clear_job_res_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.job_res_req_ != nullptr) {
    delete _impl_.job_res_req_;
  }
  _impl_.job_res_req_ = nullptr;
}
inline const ::croupier::server::v1::TunnelJobResultRequest& TunnelMessage::_internal_job_res_req() const {
  const ::croupier::server::v1::TunnelJobResultRequest* p = _impl_.job_res_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::server::v1::TunnelJobResultRequest&>(
      ::croupier::server::v1::_TunnelJobResultRequest_default_instance_);
}
inline const ::croupier::server::v1::TunnelJobResultRequest& TunnelMessage::job_res_req() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.job_res_req)
  return _internal_job_res_req();
}
inline void TunnelMessage::unsafe_arena_set_allocated_job_res_req(
    ::croupier::server::v1::TunnelJobResultRequest* job_res_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.job_res_req_);
  }
  _impl_.job_res_req_ = job_res_req;
  if (job_res_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.server.v1.TunnelMessage.job_res_req)
}
inline ::croupier::server::v1::TunnelJobResultRequest* TunnelMessage::release_job_res_req() {
  
  ::croupier::server::v1::TunnelJobResultRequest* temp = _impl_.job_res_req_;
  _impl_.job_res_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::croupier::server::v1::TunnelJobResultRequest* TunnelMessage::unsafe_arena_release_job_res_req() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.job_res_req)
  
  ::croupier::server::v1::TunnelJobResultRequest* temp = _impl_.job_res_req_;
  _impl_.job_res_req_ = nullptr;
  return temp;
}
inline ::croupier::server::v1::TunnelJobResultRequest* TunnelMessage::_internal_mutable_job_res_req() {
  
  if (_impl_.job_res_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::server::v1::TunnelJobResultRequest>(GetArenaForAllocation());
    _impl_.job_res_req_ = p;
  }
  return _impl_.job_res_req_;
}
inline ::croupier::server::v1::TunnelJobResultRequest* TunnelMessage::mutable_job_res_req() {
  ::croupier::server::v1::TunnelJobResultRequest* _msg = _internal_mutable_job_res_req();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.job_res_req)
  return _msg;
}
inline void TunnelMessage::set_allocated_job_res_req(::croupier::server::v1::TunnelJobResultRequest* job_res_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.job_res_req_;
  }
  if (job_res_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(job_res_req);
    if (message_arena != submessage_arena) {
      job_res_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job_res_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.job_res_req_ = job_res_req;
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.job_res_req)
}

// .croupier.server.v1.TunnelJobResultResponse job_res_res = 9;
inline bool TunnelMessage::_internal_has_job_res_res() const {
  return this != internal_default_instance() && _impl_.job_res_res_ != nullptr;
}
inline bool TunnelMessage::has_job_res_res() const {
  return _internal_has_job_res_res();
}
inline void TunnelMessage::clear_job_res_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.job_res_res_ != nullptr) {
    delete _impl_.job_res_res_;
  }
  _impl_.job_res_res_ = nullptr;
}
inline const ::croupier::server::v1::TunnelJobResultResponse& TunnelMessage::_internal_job_res_res() const {
  const ::croupier::server::v1::TunnelJobResultResponse* p = _impl_.job_res_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::server::v1::TunnelJobResultResponse&>(
      ::croupier::server::v1::_TunnelJobResultResponse_default_instance_);
}
inline const ::croupier::server::v1::TunnelJobResultResponse& TunnelMessage::job_res_res() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.job_res_res)
  return _internal_job_res_res();
}
inline void TunnelMessage::unsafe_arena_set_allocated_job_res_res(
    ::croupier::server::v1::TunnelJobResultResponse* job_res_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.job_res_res_);
  }
  _impl_.job_res_res_ = job_res_res;
  if (job_res_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.server.v1.TunnelMessage.job_res_res)
}
inline ::croupier::server::v1::TunnelJobResultResponse* TunnelMessage::release_job_res_res() {
  
  ::croupier::server::v1::TunnelJobResultResponse* temp = _impl_.job_res_res_;
  _impl_.job_res_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::croupier::server::v1::TunnelJobResultResponse* TunnelMessage::unsafe_arena_release_job_res_res() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.job_res_res)
  
  ::croupier::server::v1::TunnelJobResultResponse* temp = _impl_.job_res_res_;
  _impl_.job_res_res_ = nullptr;
  return temp;
}
inline ::croupier::server::v1::TunnelJobResultResponse* TunnelMessage::_internal_mutable_job_res_res() {
  
  if (_impl_.job_res_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::server::v1::TunnelJobResultResponse>(GetArenaForAllocation());
    _impl_.job_res_res_ = p;
  }
  return _impl_.job_res_res_;
}
inline ::croupier::server::v1::TunnelJobResultResponse* TunnelMessage::mutable_job_res_res() {
  ::croupier::server::v1::TunnelJobResultResponse* _msg = _internal_mutable_job_res_res();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.job_res_res)
  return _msg;
}
inline void TunnelMessage::set_allocated_job_res_res(::croupier::server::v1::TunnelJobResultResponse* job_res_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.job_res_res_;
  }
  if (job_res_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(job_res_res);
    if (message_arena != submessage_arena) {
      job_res_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job_res_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.job_res_res_ = job_res_res;
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.job_res_res)
}

// .croupier.server.v1.InvokeFrame invoke = 10;
inline bool TunnelMessage::_internal_has_invoke() const {
  return this != internal_default_instance() && _impl_.invoke_ != nullptr;
}
inline bool TunnelMessage::has_invoke() const {
  return _internal_has_invoke();
}
inline void TunnelMessage::clear_invoke() {
  if (GetArenaForAllocation() == nullptr && _impl_.invoke_ != nullptr) {
    delete _impl_.invoke_;
  }
  _impl_.invoke_ = nullptr;
}
inline const ::croupier::server::v1::InvokeFrame& TunnelMessage::_internal_invoke() const {
  const ::croupier::server::v1::InvokeFrame* p = _impl_.invoke_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::server::v1::InvokeFrame&>(
      ::croupier::server::v1::_InvokeFrame_default_instance_);
}
inline const ::croupier::server::v1::InvokeFrame& TunnelMessage::invoke() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.invoke)
  return _internal_invoke();
}
inline void TunnelMessage::unsafe_arena_set_allocated_invoke(
    ::croupier::server::v1::InvokeFrame* invoke) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.invoke_);
  }
  _impl_.invoke_ = invoke;
  if (invoke) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.server.v1.TunnelMessage.invoke)
}
inline ::croupier::server::v1::InvokeFrame* TunnelMessage::release_invoke() {
  
  ::croupier::server::v1::InvokeFrame* temp = _impl_.invoke_;
  _impl_.invoke_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::croupier::server::v1::InvokeFrame* TunnelMessage::unsafe_arena_release_invoke() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.invoke)
  
  ::croupier::server::v1::InvokeFrame* temp = _impl_.invoke_;
  _impl_.invoke_ = nullptr;
  return temp;
}
inline ::croupier::server::v1::InvokeFrame* TunnelMessage::_internal_mutable_invoke() {
  
  if (_impl_.invoke_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::server::v1::InvokeFrame>(GetArenaForAllocation());
    _impl_.invoke_ = p;
  }
  return _impl_.invoke_;
}
inline ::croupier::server::v1::InvokeFrame* TunnelMessage::mutable_invoke() {
  ::croupier::server::v1::InvokeFrame* _msg = _internal_mutable_invoke();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.invoke)
  return _msg;
}
inline void TunnelMessage::set_allocated_invoke(::croupier::server::v1::InvokeFrame* invoke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.invoke_;
  }
  if (invoke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invoke);
    if (message_arena != submessage_arena) {
      invoke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invoke, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.invoke_ = invoke;
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.invoke)
}

// .croupier.server.v1.StartJobFrame start = 11;
inline bool TunnelMessage::_internal_has_start() const {
  return this != internal_default_instance() && _impl_.start_ != nullptr;
}
inline bool TunnelMessage::has_start() const {
  return _internal_has_start();
}
inline void TunnelMessage::clear_start() {
  if (GetArenaForAllocation() == nullptr && _impl_.start_ != nullptr) {
    delete _impl_.start_;
  }
  _impl_.start_ = nullptr;
}
inline const ::croupier::server::v1::StartJobFrame& TunnelMessage::_internal_start() const {
  const ::croupier::server::v1::StartJobFrame* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::server::v1::StartJobFrame&>(
      ::croupier::server::v1::_StartJobFrame_default_instance_);
}
inline const ::croupier::server::v1::StartJobFrame& TunnelMessage::start() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.start)
  return _internal_start();
}
inline void TunnelMessage::unsafe_arena_set_allocated_start(
    ::croupier::server::v1::StartJobFrame* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.server.v1.TunnelMessage.start)
}
inline ::croupier::server::v1::StartJobFrame* TunnelMessage::release_start() {
  
  ::croupier::server::v1::StartJobFrame* temp = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::croupier::server::v1::StartJobFrame* TunnelMessage::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.start)
  
  ::croupier::server::v1::StartJobFrame* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::croupier::server::v1::StartJobFrame* TunnelMessage::_internal_mutable_start() {
  
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::server::v1::StartJobFrame>(GetArenaForAllocation());
    _impl_.start_ = p;
  }
  return _impl_.start_;
}
inline ::croupier::server::v1::StartJobFrame* TunnelMessage::mutable_start() {
  ::croupier::server::v1::StartJobFrame* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.start)
  return _msg;
}
inline void TunnelMessage::set_allocated_start(::croupier::server::v1::StartJobFrame* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.start)
}

// .croupier.server.v1.CancelJobFrame cancel = 12;
inline bool TunnelMessage::_internal_has_cancel() const {
  return this != internal_default_instance() && _impl_.cancel_ != nullptr;
}
inline bool TunnelMessage::has_cancel() const {
  return _internal_has_cancel();
}
inline void TunnelMessage::clear_cancel() {
  if (GetArenaForAllocation() == nullptr && _impl_.cancel_ != nullptr) {
    delete _impl_.cancel_;
  }
  _impl_.cancel_ = nullptr;
}
inline const ::croupier::server::v1::CancelJobFrame& TunnelMessage::_internal_cancel() const {
  const ::croupier::server::v1::CancelJobFrame* p = _impl_.cancel_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::server::v1::CancelJobFrame&>(
      ::croupier::server::v1::_CancelJobFrame_default_instance_);
}
inline const ::croupier::server::v1::CancelJobFrame& TunnelMessage::cancel() const {
  // @@protoc_insertion_point(field_get:croupier.server.v1.TunnelMessage.cancel)
  return _internal_cancel();
}
inline void TunnelMessage::unsafe_arena_set_allocated_cancel(
    ::croupier::server::v1::CancelJobFrame* cancel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_);
  }
  _impl_.cancel_ = cancel;
  if (cancel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.server.v1.TunnelMessage.cancel)
}
inline ::croupier::server::v1::CancelJobFrame* TunnelMessage::release_cancel() {
  
  ::croupier::server::v1::CancelJobFrame* temp = _impl_.cancel_;
  _impl_.cancel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::croupier::server::v1::CancelJobFrame* TunnelMessage::unsafe_arena_release_cancel() {
  // @@protoc_insertion_point(field_release:croupier.server.v1.TunnelMessage.cancel)
  
  ::croupier::server::v1::CancelJobFrame* temp = _impl_.cancel_;
  _impl_.cancel_ = nullptr;
  return temp;
}
inline ::croupier::server::v1::CancelJobFrame* TunnelMessage::_internal_mutable_cancel() {
  
  if (_impl_.cancel_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::server::v1::CancelJobFrame>(GetArenaForAllocation());
    _impl_.cancel_ = p;
  }
  return _impl_.cancel_;
}
inline ::croupier::server::v1::CancelJobFrame* TunnelMessage::mutable_cancel() {
  ::croupier::server::v1::CancelJobFrame* _msg = _internal_mutable_cancel();
  // @@protoc_insertion_point(field_mutable:croupier.server.v1.TunnelMessage.cancel)
  return _msg;
}
inline void TunnelMessage::set_allocated_cancel(::croupier::server::v1::CancelJobFrame* cancel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cancel_;
  }
  if (cancel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cancel);
    if (message_arena != submessage_arena) {
      cancel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cancel_ = cancel;
  // @@protoc_insertion_point(field_set_allocated:croupier.server.v1.TunnelMessage.cancel)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace server
}  // namespace croupier

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_croupier_2fserver_2fv1_2ftunnel_2eproto
