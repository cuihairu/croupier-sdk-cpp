// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: croupier/ops/v1/ops.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_croupier_2fops_2fv1_2fops_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_croupier_2fops_2fv1_2fops_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_croupier_2fops_2fv1_2fops_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_croupier_2fops_2fv1_2fops_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_croupier_2fops_2fv1_2fops_2eproto;
namespace croupier {
namespace ops {
namespace v1 {
class CpuMetrics;
struct CpuMetricsDefaultTypeInternal;
extern CpuMetricsDefaultTypeInternal _CpuMetrics_default_instance_;
class CronJob;
struct CronJobDefaultTypeInternal;
extern CronJobDefaultTypeInternal _CronJob_default_instance_;
class DiskMetrics;
struct DiskMetricsDefaultTypeInternal;
extern DiskMetricsDefaultTypeInternal _DiskMetrics_default_instance_;
class ExecuteCommandRequest;
struct ExecuteCommandRequestDefaultTypeInternal;
extern ExecuteCommandRequestDefaultTypeInternal _ExecuteCommandRequest_default_instance_;
class ExecuteCommandRequest_EnvEntry_DoNotUse;
struct ExecuteCommandRequest_EnvEntry_DoNotUseDefaultTypeInternal;
extern ExecuteCommandRequest_EnvEntry_DoNotUseDefaultTypeInternal _ExecuteCommandRequest_EnvEntry_DoNotUse_default_instance_;
class ExecuteCommandResponse;
struct ExecuteCommandResponseDefaultTypeInternal;
extern ExecuteCommandResponseDefaultTypeInternal _ExecuteCommandResponse_default_instance_;
class GetServiceStatusRequest;
struct GetServiceStatusRequestDefaultTypeInternal;
extern GetServiceStatusRequestDefaultTypeInternal _GetServiceStatusRequest_default_instance_;
class GetServiceStatusResponse;
struct GetServiceStatusResponseDefaultTypeInternal;
extern GetServiceStatusResponseDefaultTypeInternal _GetServiceStatusResponse_default_instance_;
class ListCronJobsResponse;
struct ListCronJobsResponseDefaultTypeInternal;
extern ListCronJobsResponseDefaultTypeInternal _ListCronJobsResponse_default_instance_;
class ListProcessesResponse;
struct ListProcessesResponseDefaultTypeInternal;
extern ListProcessesResponseDefaultTypeInternal _ListProcessesResponse_default_instance_;
class ListServicesRequest;
struct ListServicesRequestDefaultTypeInternal;
extern ListServicesRequestDefaultTypeInternal _ListServicesRequest_default_instance_;
class ListServicesResponse;
struct ListServicesResponseDefaultTypeInternal;
extern ListServicesResponseDefaultTypeInternal _ListServicesResponse_default_instance_;
class ManagedProcess;
struct ManagedProcessDefaultTypeInternal;
extern ManagedProcessDefaultTypeInternal _ManagedProcess_default_instance_;
class MemoryMetrics;
struct MemoryMetricsDefaultTypeInternal;
extern MemoryMetricsDefaultTypeInternal _MemoryMetrics_default_instance_;
class MetricsReport;
struct MetricsReportDefaultTypeInternal;
extern MetricsReportDefaultTypeInternal _MetricsReport_default_instance_;
class MetricsReport_CustomEntry_DoNotUse;
struct MetricsReport_CustomEntry_DoNotUseDefaultTypeInternal;
extern MetricsReport_CustomEntry_DoNotUseDefaultTypeInternal _MetricsReport_CustomEntry_DoNotUse_default_instance_;
class NetworkMetrics;
struct NetworkMetricsDefaultTypeInternal;
extern NetworkMetricsDefaultTypeInternal _NetworkMetrics_default_instance_;
class OpsStatus;
struct OpsStatusDefaultTypeInternal;
extern OpsStatusDefaultTypeInternal _OpsStatus_default_instance_;
class ProcessMetrics;
struct ProcessMetricsDefaultTypeInternal;
extern ProcessMetricsDefaultTypeInternal _ProcessMetrics_default_instance_;
class RestartProcessRequest;
struct RestartProcessRequestDefaultTypeInternal;
extern RestartProcessRequestDefaultTypeInternal _RestartProcessRequest_default_instance_;
class RestartProcessResponse;
struct RestartProcessResponseDefaultTypeInternal;
extern RestartProcessResponseDefaultTypeInternal _RestartProcessResponse_default_instance_;
class ServiceInfo;
struct ServiceInfoDefaultTypeInternal;
extern ServiceInfoDefaultTypeInternal _ServiceInfo_default_instance_;
class StartProcessRequest;
struct StartProcessRequestDefaultTypeInternal;
extern StartProcessRequestDefaultTypeInternal _StartProcessRequest_default_instance_;
class StartProcessResponse;
struct StartProcessResponseDefaultTypeInternal;
extern StartProcessResponseDefaultTypeInternal _StartProcessResponse_default_instance_;
class StopProcessRequest;
struct StopProcessRequestDefaultTypeInternal;
extern StopProcessRequestDefaultTypeInternal _StopProcessRequest_default_instance_;
class StopProcessResponse;
struct StopProcessResponseDefaultTypeInternal;
extern StopProcessResponseDefaultTypeInternal _StopProcessResponse_default_instance_;
class SystemInfo;
struct SystemInfoDefaultTypeInternal;
extern SystemInfoDefaultTypeInternal _SystemInfo_default_instance_;
}  // namespace v1
}  // namespace ops
}  // namespace croupier
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace croupier {
namespace ops {
namespace v1 {
enum ProcessState : int {
  PROCESS_STATE_UNSPECIFIED = 0,
  PROCESS_STATE_RUNNING = 1,
  PROCESS_STATE_STOPPED = 2,
  PROCESS_STATE_FAILED = 3,
  PROCESS_STATE_STARTING = 4,
  PROCESS_STATE_STOPPING = 5,
  ProcessState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ProcessState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ProcessState_IsValid(int value);
extern const uint32_t ProcessState_internal_data_[];
constexpr ProcessState ProcessState_MIN = static_cast<ProcessState>(0);
constexpr ProcessState ProcessState_MAX = static_cast<ProcessState>(5);
constexpr int ProcessState_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ProcessState_descriptor();
template <typename T>
const std::string& ProcessState_Name(T value) {
  static_assert(std::is_same<T, ProcessState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProcessState_Name().");
  return ProcessState_Name(static_cast<ProcessState>(value));
}
template <>
inline const std::string& ProcessState_Name(ProcessState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ProcessState_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ProcessState_Parse(absl::string_view name, ProcessState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcessState>(
      ProcessState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class StopProcessResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.StopProcessResponse) */ {
 public:
  inline StopProcessResponse() : StopProcessResponse(nullptr) {}
  ~StopProcessResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StopProcessResponse(::google::protobuf::internal::ConstantInitialized);

  inline StopProcessResponse(const StopProcessResponse& from)
      : StopProcessResponse(nullptr, from) {}
  StopProcessResponse(StopProcessResponse&& from) noexcept
    : StopProcessResponse() {
    *this = ::std::move(from);
  }

  inline StopProcessResponse& operator=(const StopProcessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopProcessResponse& operator=(StopProcessResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopProcessResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopProcessResponse* internal_default_instance() {
    return reinterpret_cast<const StopProcessResponse*>(
               &_StopProcessResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StopProcessResponse& a, StopProcessResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopProcessResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopProcessResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopProcessResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopProcessResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StopProcessResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StopProcessResponse& from) {
    StopProcessResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StopProcessResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.StopProcessResponse";
  }
  protected:
  explicit StopProcessResponse(::google::protobuf::Arena* arena);
  StopProcessResponse(::google::protobuf::Arena* arena, const StopProcessResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.StopProcessResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class StopProcessRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.StopProcessRequest) */ {
 public:
  inline StopProcessRequest() : StopProcessRequest(nullptr) {}
  ~StopProcessRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StopProcessRequest(::google::protobuf::internal::ConstantInitialized);

  inline StopProcessRequest(const StopProcessRequest& from)
      : StopProcessRequest(nullptr, from) {}
  StopProcessRequest(StopProcessRequest&& from) noexcept
    : StopProcessRequest() {
    *this = ::std::move(from);
  }

  inline StopProcessRequest& operator=(const StopProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopProcessRequest& operator=(StopProcessRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopProcessRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopProcessRequest* internal_default_instance() {
    return reinterpret_cast<const StopProcessRequest*>(
               &_StopProcessRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StopProcessRequest& a, StopProcessRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopProcessRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopProcessRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopProcessRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopProcessRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StopProcessRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StopProcessRequest& from) {
    StopProcessRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StopProcessRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.StopProcessRequest";
  }
  protected:
  explicit StopProcessRequest(::google::protobuf::Arena* arena);
  StopProcessRequest(::google::protobuf::Arena* arena, const StopProcessRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessNameFieldNumber = 1,
    kForceFieldNumber = 2,
    kTimeoutSecondsFieldNumber = 3,
  };
  // string process_name = 1 [json_name = "processName"];
  void clear_process_name() ;
  const std::string& process_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_process_name(Arg_&& arg, Args_... args);
  std::string* mutable_process_name();
  PROTOBUF_NODISCARD std::string* release_process_name();
  void set_allocated_process_name(std::string* value);

  private:
  const std::string& _internal_process_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_process_name(
      const std::string& value);
  std::string* _internal_mutable_process_name();

  public:
  // bool force = 2 [json_name = "force"];
  void clear_force() ;
  bool force() const;
  void set_force(bool value);

  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);

  public:
  // int32 timeout_seconds = 3 [json_name = "timeoutSeconds"];
  void clear_timeout_seconds() ;
  ::int32_t timeout_seconds() const;
  void set_timeout_seconds(::int32_t value);

  private:
  ::int32_t _internal_timeout_seconds() const;
  void _internal_set_timeout_seconds(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.StopProcessRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr process_name_;
    bool force_;
    ::int32_t timeout_seconds_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class StartProcessResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.StartProcessResponse) */ {
 public:
  inline StartProcessResponse() : StartProcessResponse(nullptr) {}
  ~StartProcessResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StartProcessResponse(::google::protobuf::internal::ConstantInitialized);

  inline StartProcessResponse(const StartProcessResponse& from)
      : StartProcessResponse(nullptr, from) {}
  StartProcessResponse(StartProcessResponse&& from) noexcept
    : StartProcessResponse() {
    *this = ::std::move(from);
  }

  inline StartProcessResponse& operator=(const StartProcessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartProcessResponse& operator=(StartProcessResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartProcessResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartProcessResponse* internal_default_instance() {
    return reinterpret_cast<const StartProcessResponse*>(
               &_StartProcessResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StartProcessResponse& a, StartProcessResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartProcessResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartProcessResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartProcessResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartProcessResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StartProcessResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StartProcessResponse& from) {
    StartProcessResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StartProcessResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.StartProcessResponse";
  }
  protected:
  explicit StartProcessResponse(::google::protobuf::Arena* arena);
  StartProcessResponse(::google::protobuf::Arena* arena, const StartProcessResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kPidFieldNumber = 3,
  };
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // int32 pid = 3 [json_name = "pid"];
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.StartProcessResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    ::int32_t pid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class StartProcessRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.StartProcessRequest) */ {
 public:
  inline StartProcessRequest() : StartProcessRequest(nullptr) {}
  ~StartProcessRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StartProcessRequest(::google::protobuf::internal::ConstantInitialized);

  inline StartProcessRequest(const StartProcessRequest& from)
      : StartProcessRequest(nullptr, from) {}
  StartProcessRequest(StartProcessRequest&& from) noexcept
    : StartProcessRequest() {
    *this = ::std::move(from);
  }

  inline StartProcessRequest& operator=(const StartProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartProcessRequest& operator=(StartProcessRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartProcessRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartProcessRequest* internal_default_instance() {
    return reinterpret_cast<const StartProcessRequest*>(
               &_StartProcessRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StartProcessRequest& a, StartProcessRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartProcessRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartProcessRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartProcessRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartProcessRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StartProcessRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StartProcessRequest& from) {
    StartProcessRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StartProcessRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.StartProcessRequest";
  }
  protected:
  explicit StartProcessRequest(::google::protobuf::Arena* arena);
  StartProcessRequest(::google::protobuf::Arena* arena, const StartProcessRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessNameFieldNumber = 1,
  };
  // string process_name = 1 [json_name = "processName"];
  void clear_process_name() ;
  const std::string& process_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_process_name(Arg_&& arg, Args_... args);
  std::string* mutable_process_name();
  PROTOBUF_NODISCARD std::string* release_process_name();
  void set_allocated_process_name(std::string* value);

  private:
  const std::string& _internal_process_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_process_name(
      const std::string& value);
  std::string* _internal_mutable_process_name();

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.StartProcessRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr process_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class ServiceInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.ServiceInfo) */ {
 public:
  inline ServiceInfo() : ServiceInfo(nullptr) {}
  ~ServiceInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ServiceInfo(::google::protobuf::internal::ConstantInitialized);

  inline ServiceInfo(const ServiceInfo& from)
      : ServiceInfo(nullptr, from) {}
  ServiceInfo(ServiceInfo&& from) noexcept
    : ServiceInfo() {
    *this = ::std::move(from);
  }

  inline ServiceInfo& operator=(const ServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceInfo& operator=(ServiceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceInfo* internal_default_instance() {
    return reinterpret_cast<const ServiceInfo*>(
               &_ServiceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ServiceInfo& a, ServiceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServiceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ServiceInfo& from) {
    ServiceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ServiceInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.ServiceInfo";
  }
  protected:
  explicit ServiceInfo(::google::protobuf::Arena* arena);
  ServiceInfo(::google::protobuf::Arena* arena, const ServiceInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kStatusFieldNumber = 3,
    kStartTypeFieldNumber = 4,
    kProcessIdFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string display_name = 2 [json_name = "displayName"];
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* value);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // string status = 3 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // string start_type = 4 [json_name = "startType"];
  void clear_start_type() ;
  const std::string& start_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_type(Arg_&& arg, Args_... args);
  std::string* mutable_start_type();
  PROTOBUF_NODISCARD std::string* release_start_type();
  void set_allocated_start_type(std::string* value);

  private:
  const std::string& _internal_start_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_type(
      const std::string& value);
  std::string* _internal_mutable_start_type();

  public:
  // uint32 process_id = 5 [json_name = "processId"];
  void clear_process_id() ;
  ::uint32_t process_id() const;
  void set_process_id(::uint32_t value);

  private:
  ::uint32_t _internal_process_id() const;
  void _internal_set_process_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.ServiceInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr start_type_;
    ::uint32_t process_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class RestartProcessResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.RestartProcessResponse) */ {
 public:
  inline RestartProcessResponse() : RestartProcessResponse(nullptr) {}
  ~RestartProcessResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RestartProcessResponse(::google::protobuf::internal::ConstantInitialized);

  inline RestartProcessResponse(const RestartProcessResponse& from)
      : RestartProcessResponse(nullptr, from) {}
  RestartProcessResponse(RestartProcessResponse&& from) noexcept
    : RestartProcessResponse() {
    *this = ::std::move(from);
  }

  inline RestartProcessResponse& operator=(const RestartProcessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestartProcessResponse& operator=(RestartProcessResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestartProcessResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RestartProcessResponse* internal_default_instance() {
    return reinterpret_cast<const RestartProcessResponse*>(
               &_RestartProcessResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RestartProcessResponse& a, RestartProcessResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RestartProcessResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestartProcessResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestartProcessResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestartProcessResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RestartProcessResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RestartProcessResponse& from) {
    RestartProcessResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RestartProcessResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.RestartProcessResponse";
  }
  protected:
  explicit RestartProcessResponse(::google::protobuf::Arena* arena);
  RestartProcessResponse(::google::protobuf::Arena* arena, const RestartProcessResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kNewPidFieldNumber = 3,
  };
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // int32 new_pid = 3 [json_name = "newPid"];
  void clear_new_pid() ;
  ::int32_t new_pid() const;
  void set_new_pid(::int32_t value);

  private:
  ::int32_t _internal_new_pid() const;
  void _internal_set_new_pid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.RestartProcessResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    ::int32_t new_pid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class RestartProcessRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.RestartProcessRequest) */ {
 public:
  inline RestartProcessRequest() : RestartProcessRequest(nullptr) {}
  ~RestartProcessRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RestartProcessRequest(::google::protobuf::internal::ConstantInitialized);

  inline RestartProcessRequest(const RestartProcessRequest& from)
      : RestartProcessRequest(nullptr, from) {}
  RestartProcessRequest(RestartProcessRequest&& from) noexcept
    : RestartProcessRequest() {
    *this = ::std::move(from);
  }

  inline RestartProcessRequest& operator=(const RestartProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestartProcessRequest& operator=(RestartProcessRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestartProcessRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RestartProcessRequest* internal_default_instance() {
    return reinterpret_cast<const RestartProcessRequest*>(
               &_RestartProcessRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RestartProcessRequest& a, RestartProcessRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RestartProcessRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestartProcessRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestartProcessRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestartProcessRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RestartProcessRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RestartProcessRequest& from) {
    RestartProcessRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RestartProcessRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.RestartProcessRequest";
  }
  protected:
  explicit RestartProcessRequest(::google::protobuf::Arena* arena);
  RestartProcessRequest(::google::protobuf::Arena* arena, const RestartProcessRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessNameFieldNumber = 1,
    kForceFieldNumber = 2,
    kTimeoutSecondsFieldNumber = 3,
  };
  // string process_name = 1 [json_name = "processName"];
  void clear_process_name() ;
  const std::string& process_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_process_name(Arg_&& arg, Args_... args);
  std::string* mutable_process_name();
  PROTOBUF_NODISCARD std::string* release_process_name();
  void set_allocated_process_name(std::string* value);

  private:
  const std::string& _internal_process_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_process_name(
      const std::string& value);
  std::string* _internal_mutable_process_name();

  public:
  // bool force = 2 [json_name = "force"];
  void clear_force() ;
  bool force() const;
  void set_force(bool value);

  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);

  public:
  // int32 timeout_seconds = 3 [json_name = "timeoutSeconds"];
  void clear_timeout_seconds() ;
  ::int32_t timeout_seconds() const;
  void set_timeout_seconds(::int32_t value);

  private:
  ::int32_t _internal_timeout_seconds() const;
  void _internal_set_timeout_seconds(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.RestartProcessRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr process_name_;
    bool force_;
    ::int32_t timeout_seconds_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class OpsStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.OpsStatus) */ {
 public:
  inline OpsStatus() : OpsStatus(nullptr) {}
  ~OpsStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OpsStatus(::google::protobuf::internal::ConstantInitialized);

  inline OpsStatus(const OpsStatus& from)
      : OpsStatus(nullptr, from) {}
  OpsStatus(OpsStatus&& from) noexcept
    : OpsStatus() {
    *this = ::std::move(from);
  }

  inline OpsStatus& operator=(const OpsStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpsStatus& operator=(OpsStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpsStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpsStatus* internal_default_instance() {
    return reinterpret_cast<const OpsStatus*>(
               &_OpsStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OpsStatus& a, OpsStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(OpsStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpsStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpsStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpsStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpsStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OpsStatus& from) {
    OpsStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OpsStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.OpsStatus";
  }
  protected:
  explicit OpsStatus(::google::protobuf::Arena* arena);
  OpsStatus(::google::protobuf::Arena* arena, const OpsStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManagedProcessesFieldNumber = 4,
    kEnabledFieldNumber = 1,
    kAllowRestartFieldNumber = 2,
    kAllowExecFieldNumber = 3,
  };
  // repeated string managed_processes = 4 [json_name = "managedProcesses"];
  int managed_processes_size() const;
  private:
  int _internal_managed_processes_size() const;

  public:
  void clear_managed_processes() ;
  const std::string& managed_processes(int index) const;
  std::string* mutable_managed_processes(int index);
  void set_managed_processes(int index, const std::string& value);
  void set_managed_processes(int index, std::string&& value);
  void set_managed_processes(int index, const char* value);
  void set_managed_processes(int index, const char* value, std::size_t size);
  void set_managed_processes(int index, absl::string_view value);
  std::string* add_managed_processes();
  void add_managed_processes(const std::string& value);
  void add_managed_processes(std::string&& value);
  void add_managed_processes(const char* value);
  void add_managed_processes(const char* value, std::size_t size);
  void add_managed_processes(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& managed_processes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_managed_processes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_managed_processes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_managed_processes();

  public:
  // bool enabled = 1 [json_name = "enabled"];
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // bool allow_restart = 2 [json_name = "allowRestart"];
  void clear_allow_restart() ;
  bool allow_restart() const;
  void set_allow_restart(bool value);

  private:
  bool _internal_allow_restart() const;
  void _internal_set_allow_restart(bool value);

  public:
  // bool allow_exec = 3 [json_name = "allowExec"];
  void clear_allow_exec() ;
  bool allow_exec() const;
  void set_allow_exec(bool value);

  private:
  bool _internal_allow_exec() const;
  void _internal_set_allow_exec(bool value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.OpsStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> managed_processes_;
    bool enabled_;
    bool allow_restart_;
    bool allow_exec_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class NetworkMetrics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.NetworkMetrics) */ {
 public:
  inline NetworkMetrics() : NetworkMetrics(nullptr) {}
  ~NetworkMetrics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkMetrics(::google::protobuf::internal::ConstantInitialized);

  inline NetworkMetrics(const NetworkMetrics& from)
      : NetworkMetrics(nullptr, from) {}
  NetworkMetrics(NetworkMetrics&& from) noexcept
    : NetworkMetrics() {
    *this = ::std::move(from);
  }

  inline NetworkMetrics& operator=(const NetworkMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkMetrics& operator=(NetworkMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkMetrics* internal_default_instance() {
    return reinterpret_cast<const NetworkMetrics*>(
               &_NetworkMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NetworkMetrics& a, NetworkMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkMetrics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkMetrics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkMetrics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NetworkMetrics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NetworkMetrics& from) {
    NetworkMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NetworkMetrics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.NetworkMetrics";
  }
  protected:
  explicit NetworkMetrics(::google::protobuf::Arena* arena);
  NetworkMetrics(::google::protobuf::Arena* arena, const NetworkMetrics& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterfaceFieldNumber = 1,
    kBytesSentFieldNumber = 2,
    kBytesRecvFieldNumber = 3,
    kPacketsSentFieldNumber = 4,
    kPacketsRecvFieldNumber = 5,
    kErrorsInFieldNumber = 6,
    kErrorsOutFieldNumber = 7,
  };
  // string interface = 1 [json_name = "interface"];
  void clear_interface() ;
  const std::string& interface() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interface(Arg_&& arg, Args_... args);
  std::string* mutable_interface();
  PROTOBUF_NODISCARD std::string* release_interface();
  void set_allocated_interface(std::string* value);

  private:
  const std::string& _internal_interface() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface(
      const std::string& value);
  std::string* _internal_mutable_interface();

  public:
  // uint64 bytes_sent = 2 [json_name = "bytesSent"];
  void clear_bytes_sent() ;
  ::uint64_t bytes_sent() const;
  void set_bytes_sent(::uint64_t value);

  private:
  ::uint64_t _internal_bytes_sent() const;
  void _internal_set_bytes_sent(::uint64_t value);

  public:
  // uint64 bytes_recv = 3 [json_name = "bytesRecv"];
  void clear_bytes_recv() ;
  ::uint64_t bytes_recv() const;
  void set_bytes_recv(::uint64_t value);

  private:
  ::uint64_t _internal_bytes_recv() const;
  void _internal_set_bytes_recv(::uint64_t value);

  public:
  // uint64 packets_sent = 4 [json_name = "packetsSent"];
  void clear_packets_sent() ;
  ::uint64_t packets_sent() const;
  void set_packets_sent(::uint64_t value);

  private:
  ::uint64_t _internal_packets_sent() const;
  void _internal_set_packets_sent(::uint64_t value);

  public:
  // uint64 packets_recv = 5 [json_name = "packetsRecv"];
  void clear_packets_recv() ;
  ::uint64_t packets_recv() const;
  void set_packets_recv(::uint64_t value);

  private:
  ::uint64_t _internal_packets_recv() const;
  void _internal_set_packets_recv(::uint64_t value);

  public:
  // uint64 errors_in = 6 [json_name = "errorsIn"];
  void clear_errors_in() ;
  ::uint64_t errors_in() const;
  void set_errors_in(::uint64_t value);

  private:
  ::uint64_t _internal_errors_in() const;
  void _internal_set_errors_in(::uint64_t value);

  public:
  // uint64 errors_out = 7 [json_name = "errorsOut"];
  void clear_errors_out() ;
  ::uint64_t errors_out() const;
  void set_errors_out(::uint64_t value);

  private:
  ::uint64_t _internal_errors_out() const;
  void _internal_set_errors_out(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.NetworkMetrics)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr interface_;
    ::uint64_t bytes_sent_;
    ::uint64_t bytes_recv_;
    ::uint64_t packets_sent_;
    ::uint64_t packets_recv_;
    ::uint64_t errors_in_;
    ::uint64_t errors_out_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class MetricsReport_CustomEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          MetricsReport_CustomEntry_DoNotUse, std::string, double,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      MetricsReport_CustomEntry_DoNotUse, std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>;
  MetricsReport_CustomEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MetricsReport_CustomEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit MetricsReport_CustomEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const MetricsReport_CustomEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const MetricsReport_CustomEntry_DoNotUse*>(
        &_MetricsReport_CustomEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "croupier.ops.v1.MetricsReport.CustomEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};
// -------------------------------------------------------------------

class MemoryMetrics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.MemoryMetrics) */ {
 public:
  inline MemoryMetrics() : MemoryMetrics(nullptr) {}
  ~MemoryMetrics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemoryMetrics(::google::protobuf::internal::ConstantInitialized);

  inline MemoryMetrics(const MemoryMetrics& from)
      : MemoryMetrics(nullptr, from) {}
  MemoryMetrics(MemoryMetrics&& from) noexcept
    : MemoryMetrics() {
    *this = ::std::move(from);
  }

  inline MemoryMetrics& operator=(const MemoryMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoryMetrics& operator=(MemoryMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemoryMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemoryMetrics* internal_default_instance() {
    return reinterpret_cast<const MemoryMetrics*>(
               &_MemoryMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MemoryMetrics& a, MemoryMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoryMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoryMetrics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemoryMetrics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemoryMetrics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MemoryMetrics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MemoryMetrics& from) {
    MemoryMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MemoryMetrics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.MemoryMetrics";
  }
  protected:
  explicit MemoryMetrics(::google::protobuf::Arena* arena);
  MemoryMetrics(::google::protobuf::Arena* arena, const MemoryMetrics& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalBytesFieldNumber = 1,
    kUsedBytesFieldNumber = 2,
    kAvailableBytesFieldNumber = 3,
    kUsagePercentFieldNumber = 4,
    kSwapTotalFieldNumber = 5,
    kSwapUsedFieldNumber = 6,
  };
  // uint64 total_bytes = 1 [json_name = "totalBytes"];
  void clear_total_bytes() ;
  ::uint64_t total_bytes() const;
  void set_total_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_total_bytes() const;
  void _internal_set_total_bytes(::uint64_t value);

  public:
  // uint64 used_bytes = 2 [json_name = "usedBytes"];
  void clear_used_bytes() ;
  ::uint64_t used_bytes() const;
  void set_used_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_used_bytes() const;
  void _internal_set_used_bytes(::uint64_t value);

  public:
  // uint64 available_bytes = 3 [json_name = "availableBytes"];
  void clear_available_bytes() ;
  ::uint64_t available_bytes() const;
  void set_available_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_available_bytes() const;
  void _internal_set_available_bytes(::uint64_t value);

  public:
  // double usage_percent = 4 [json_name = "usagePercent"];
  void clear_usage_percent() ;
  double usage_percent() const;
  void set_usage_percent(double value);

  private:
  double _internal_usage_percent() const;
  void _internal_set_usage_percent(double value);

  public:
  // uint64 swap_total = 5 [json_name = "swapTotal"];
  void clear_swap_total() ;
  ::uint64_t swap_total() const;
  void set_swap_total(::uint64_t value);

  private:
  ::uint64_t _internal_swap_total() const;
  void _internal_set_swap_total(::uint64_t value);

  public:
  // uint64 swap_used = 6 [json_name = "swapUsed"];
  void clear_swap_used() ;
  ::uint64_t swap_used() const;
  void set_swap_used(::uint64_t value);

  private:
  ::uint64_t _internal_swap_used() const;
  void _internal_set_swap_used(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.MemoryMetrics)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t total_bytes_;
    ::uint64_t used_bytes_;
    ::uint64_t available_bytes_;
    double usage_percent_;
    ::uint64_t swap_total_;
    ::uint64_t swap_used_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class ListServicesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.ListServicesRequest) */ {
 public:
  inline ListServicesRequest() : ListServicesRequest(nullptr) {}
  ~ListServicesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListServicesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListServicesRequest(const ListServicesRequest& from)
      : ListServicesRequest(nullptr, from) {}
  ListServicesRequest(ListServicesRequest&& from) noexcept
    : ListServicesRequest() {
    *this = ::std::move(from);
  }

  inline ListServicesRequest& operator=(const ListServicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServicesRequest& operator=(ListServicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServicesRequest* internal_default_instance() {
    return reinterpret_cast<const ListServicesRequest*>(
               &_ListServicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListServicesRequest& a, ListServicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServicesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServicesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServicesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListServicesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListServicesRequest& from) {
    ListServicesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListServicesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.ListServicesRequest";
  }
  protected:
  explicit ListServicesRequest(::google::protobuf::Arena* arena);
  ListServicesRequest(::google::protobuf::Arena* arena, const ListServicesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kNamePatternFieldNumber = 2,
    kLimitFieldNumber = 3,
  };
  // string state = 1 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* value);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // string name_pattern = 2 [json_name = "namePattern"];
  void clear_name_pattern() ;
  const std::string& name_pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_name_pattern();
  PROTOBUF_NODISCARD std::string* release_name_pattern();
  void set_allocated_name_pattern(std::string* value);

  private:
  const std::string& _internal_name_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_pattern(
      const std::string& value);
  std::string* _internal_mutable_name_pattern();

  public:
  // int32 limit = 3 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.ListServicesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr state_;
    ::google::protobuf::internal::ArenaStringPtr name_pattern_;
    ::int32_t limit_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class GetServiceStatusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.GetServiceStatusResponse) */ {
 public:
  inline GetServiceStatusResponse() : GetServiceStatusResponse(nullptr) {}
  ~GetServiceStatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetServiceStatusResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetServiceStatusResponse(const GetServiceStatusResponse& from)
      : GetServiceStatusResponse(nullptr, from) {}
  GetServiceStatusResponse(GetServiceStatusResponse&& from) noexcept
    : GetServiceStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetServiceStatusResponse& operator=(const GetServiceStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceStatusResponse& operator=(GetServiceStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetServiceStatusResponse*>(
               &_GetServiceStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetServiceStatusResponse& a, GetServiceStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceStatusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceStatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetServiceStatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetServiceStatusResponse& from) {
    GetServiceStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetServiceStatusResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.GetServiceStatusResponse";
  }
  protected:
  explicit GetServiceStatusResponse(::google::protobuf::Arena* arena);
  GetServiceStatusResponse(::google::protobuf::Arena* arena, const GetServiceStatusResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kStatusFieldNumber = 3,
    kStartTypeFieldNumber = 4,
    kBinaryPathFieldNumber = 6,
    kDescriptionFieldNumber = 7,
    kProcessIdFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string display_name = 2 [json_name = "displayName"];
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* value);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // string status = 3 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // string start_type = 4 [json_name = "startType"];
  void clear_start_type() ;
  const std::string& start_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_type(Arg_&& arg, Args_... args);
  std::string* mutable_start_type();
  PROTOBUF_NODISCARD std::string* release_start_type();
  void set_allocated_start_type(std::string* value);

  private:
  const std::string& _internal_start_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_type(
      const std::string& value);
  std::string* _internal_mutable_start_type();

  public:
  // string binary_path = 6 [json_name = "binaryPath"];
  void clear_binary_path() ;
  const std::string& binary_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_binary_path(Arg_&& arg, Args_... args);
  std::string* mutable_binary_path();
  PROTOBUF_NODISCARD std::string* release_binary_path();
  void set_allocated_binary_path(std::string* value);

  private:
  const std::string& _internal_binary_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_path(
      const std::string& value);
  std::string* _internal_mutable_binary_path();

  public:
  // string description = 7 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // uint32 process_id = 5 [json_name = "processId"];
  void clear_process_id() ;
  ::uint32_t process_id() const;
  void set_process_id(::uint32_t value);

  private:
  ::uint32_t _internal_process_id() const;
  void _internal_set_process_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.GetServiceStatusResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      103, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr start_type_;
    ::google::protobuf::internal::ArenaStringPtr binary_path_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::uint32_t process_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class GetServiceStatusRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.GetServiceStatusRequest) */ {
 public:
  inline GetServiceStatusRequest() : GetServiceStatusRequest(nullptr) {}
  ~GetServiceStatusRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetServiceStatusRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetServiceStatusRequest(const GetServiceStatusRequest& from)
      : GetServiceStatusRequest(nullptr, from) {}
  GetServiceStatusRequest(GetServiceStatusRequest&& from) noexcept
    : GetServiceStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetServiceStatusRequest& operator=(const GetServiceStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceStatusRequest& operator=(GetServiceStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetServiceStatusRequest*>(
               &_GetServiceStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetServiceStatusRequest& a, GetServiceStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceStatusRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceStatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetServiceStatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetServiceStatusRequest& from) {
    GetServiceStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetServiceStatusRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.GetServiceStatusRequest";
  }
  protected:
  explicit GetServiceStatusRequest(::google::protobuf::Arena* arena);
  GetServiceStatusRequest(::google::protobuf::Arena* arena, const GetServiceStatusRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.GetServiceStatusRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class ExecuteCommandResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.ExecuteCommandResponse) */ {
 public:
  inline ExecuteCommandResponse() : ExecuteCommandResponse(nullptr) {}
  ~ExecuteCommandResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExecuteCommandResponse(::google::protobuf::internal::ConstantInitialized);

  inline ExecuteCommandResponse(const ExecuteCommandResponse& from)
      : ExecuteCommandResponse(nullptr, from) {}
  ExecuteCommandResponse(ExecuteCommandResponse&& from) noexcept
    : ExecuteCommandResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteCommandResponse& operator=(const ExecuteCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteCommandResponse& operator=(ExecuteCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteCommandResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteCommandResponse*>(
               &_ExecuteCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ExecuteCommandResponse& a, ExecuteCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteCommandResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteCommandResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteCommandResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExecuteCommandResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ExecuteCommandResponse& from) {
    ExecuteCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExecuteCommandResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.ExecuteCommandResponse";
  }
  protected:
  explicit ExecuteCommandResponse(::google::protobuf::Arena* arena);
  ExecuteCommandResponse(::google::protobuf::Arena* arena, const ExecuteCommandResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStdOutFieldNumber = 3,
    kStdErrFieldNumber = 4,
    kErrorFieldNumber = 5,
    kSuccessFieldNumber = 1,
    kExitCodeFieldNumber = 2,
  };
  // string std_out = 3 [json_name = "stdOut"];
  void clear_std_out() ;
  const std::string& std_out() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_std_out(Arg_&& arg, Args_... args);
  std::string* mutable_std_out();
  PROTOBUF_NODISCARD std::string* release_std_out();
  void set_allocated_std_out(std::string* value);

  private:
  const std::string& _internal_std_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_std_out(
      const std::string& value);
  std::string* _internal_mutable_std_out();

  public:
  // string std_err = 4 [json_name = "stdErr"];
  void clear_std_err() ;
  const std::string& std_err() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_std_err(Arg_&& arg, Args_... args);
  std::string* mutable_std_err();
  PROTOBUF_NODISCARD std::string* release_std_err();
  void set_allocated_std_err(std::string* value);

  private:
  const std::string& _internal_std_err() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_std_err(
      const std::string& value);
  std::string* _internal_mutable_std_err();

  public:
  // string error = 5 [json_name = "error"];
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // int32 exit_code = 2 [json_name = "exitCode"];
  void clear_exit_code() ;
  ::int32_t exit_code() const;
  void set_exit_code(::int32_t value);

  private:
  ::int32_t _internal_exit_code() const;
  void _internal_set_exit_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.ExecuteCommandResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr std_out_;
    ::google::protobuf::internal::ArenaStringPtr std_err_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    bool success_;
    ::int32_t exit_code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class ExecuteCommandRequest_EnvEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ExecuteCommandRequest_EnvEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ExecuteCommandRequest_EnvEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ExecuteCommandRequest_EnvEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExecuteCommandRequest_EnvEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ExecuteCommandRequest_EnvEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ExecuteCommandRequest_EnvEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ExecuteCommandRequest_EnvEntry_DoNotUse*>(
        &_ExecuteCommandRequest_EnvEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "croupier.ops.v1.ExecuteCommandRequest.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "croupier.ops.v1.ExecuteCommandRequest.EnvEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};
// -------------------------------------------------------------------

class DiskMetrics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.DiskMetrics) */ {
 public:
  inline DiskMetrics() : DiskMetrics(nullptr) {}
  ~DiskMetrics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DiskMetrics(::google::protobuf::internal::ConstantInitialized);

  inline DiskMetrics(const DiskMetrics& from)
      : DiskMetrics(nullptr, from) {}
  DiskMetrics(DiskMetrics&& from) noexcept
    : DiskMetrics() {
    *this = ::std::move(from);
  }

  inline DiskMetrics& operator=(const DiskMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskMetrics& operator=(DiskMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskMetrics* internal_default_instance() {
    return reinterpret_cast<const DiskMetrics*>(
               &_DiskMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DiskMetrics& a, DiskMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskMetrics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskMetrics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskMetrics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiskMetrics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DiskMetrics& from) {
    DiskMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DiskMetrics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.DiskMetrics";
  }
  protected:
  explicit DiskMetrics(::google::protobuf::Arena* arena);
  DiskMetrics(::google::protobuf::Arena* arena, const DiskMetrics& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMountPointFieldNumber = 1,
    kDeviceFieldNumber = 2,
    kFsTypeFieldNumber = 3,
    kTotalBytesFieldNumber = 4,
    kUsedBytesFieldNumber = 5,
    kAvailableBytesFieldNumber = 6,
    kUsagePercentFieldNumber = 7,
    kInodeTotalFieldNumber = 8,
    kInodeUsedFieldNumber = 9,
  };
  // string mount_point = 1 [json_name = "mountPoint"];
  void clear_mount_point() ;
  const std::string& mount_point() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mount_point(Arg_&& arg, Args_... args);
  std::string* mutable_mount_point();
  PROTOBUF_NODISCARD std::string* release_mount_point();
  void set_allocated_mount_point(std::string* value);

  private:
  const std::string& _internal_mount_point() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mount_point(
      const std::string& value);
  std::string* _internal_mutable_mount_point();

  public:
  // string device = 2 [json_name = "device"];
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string fs_type = 3 [json_name = "fsType"];
  void clear_fs_type() ;
  const std::string& fs_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fs_type(Arg_&& arg, Args_... args);
  std::string* mutable_fs_type();
  PROTOBUF_NODISCARD std::string* release_fs_type();
  void set_allocated_fs_type(std::string* value);

  private:
  const std::string& _internal_fs_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fs_type(
      const std::string& value);
  std::string* _internal_mutable_fs_type();

  public:
  // uint64 total_bytes = 4 [json_name = "totalBytes"];
  void clear_total_bytes() ;
  ::uint64_t total_bytes() const;
  void set_total_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_total_bytes() const;
  void _internal_set_total_bytes(::uint64_t value);

  public:
  // uint64 used_bytes = 5 [json_name = "usedBytes"];
  void clear_used_bytes() ;
  ::uint64_t used_bytes() const;
  void set_used_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_used_bytes() const;
  void _internal_set_used_bytes(::uint64_t value);

  public:
  // uint64 available_bytes = 6 [json_name = "availableBytes"];
  void clear_available_bytes() ;
  ::uint64_t available_bytes() const;
  void set_available_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_available_bytes() const;
  void _internal_set_available_bytes(::uint64_t value);

  public:
  // double usage_percent = 7 [json_name = "usagePercent"];
  void clear_usage_percent() ;
  double usage_percent() const;
  void set_usage_percent(double value);

  private:
  double _internal_usage_percent() const;
  void _internal_set_usage_percent(double value);

  public:
  // uint64 inode_total = 8 [json_name = "inodeTotal"];
  void clear_inode_total() ;
  ::uint64_t inode_total() const;
  void set_inode_total(::uint64_t value);

  private:
  ::uint64_t _internal_inode_total() const;
  void _internal_set_inode_total(::uint64_t value);

  public:
  // uint64 inode_used = 9 [json_name = "inodeUsed"];
  void clear_inode_used() ;
  ::uint64_t inode_used() const;
  void set_inode_used(::uint64_t value);

  private:
  ::uint64_t _internal_inode_used() const;
  void _internal_set_inode_used(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.DiskMetrics)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr mount_point_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr fs_type_;
    ::uint64_t total_bytes_;
    ::uint64_t used_bytes_;
    ::uint64_t available_bytes_;
    double usage_percent_;
    ::uint64_t inode_total_;
    ::uint64_t inode_used_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class CronJob final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.CronJob) */ {
 public:
  inline CronJob() : CronJob(nullptr) {}
  ~CronJob() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CronJob(::google::protobuf::internal::ConstantInitialized);

  inline CronJob(const CronJob& from)
      : CronJob(nullptr, from) {}
  CronJob(CronJob&& from) noexcept
    : CronJob() {
    *this = ::std::move(from);
  }

  inline CronJob& operator=(const CronJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline CronJob& operator=(CronJob&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CronJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const CronJob* internal_default_instance() {
    return reinterpret_cast<const CronJob*>(
               &_CronJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CronJob& a, CronJob& b) {
    a.Swap(&b);
  }
  inline void Swap(CronJob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CronJob* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CronJob* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CronJob>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CronJob& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CronJob& from) {
    CronJob::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CronJob* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.CronJob";
  }
  protected:
  explicit CronJob(::google::protobuf::Arena* arena);
  CronJob(::google::protobuf::Arena* arena, const CronJob& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScheduleFieldNumber = 1,
    kCommandFieldNumber = 2,
    kUserFieldNumber = 3,
    kSourceFileFieldNumber = 4,
    kEnabledFieldNumber = 5,
  };
  // string schedule = 1 [json_name = "schedule"];
  void clear_schedule() ;
  const std::string& schedule() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schedule(Arg_&& arg, Args_... args);
  std::string* mutable_schedule();
  PROTOBUF_NODISCARD std::string* release_schedule();
  void set_allocated_schedule(std::string* value);

  private:
  const std::string& _internal_schedule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schedule(
      const std::string& value);
  std::string* _internal_mutable_schedule();

  public:
  // string command = 2 [json_name = "command"];
  void clear_command() ;
  const std::string& command() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_command(Arg_&& arg, Args_... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* value);

  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(
      const std::string& value);
  std::string* _internal_mutable_command();

  public:
  // string user = 3 [json_name = "user"];
  void clear_user() ;
  const std::string& user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* value);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // string source_file = 4 [json_name = "sourceFile"];
  void clear_source_file() ;
  const std::string& source_file() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_file(Arg_&& arg, Args_... args);
  std::string* mutable_source_file();
  PROTOBUF_NODISCARD std::string* release_source_file();
  void set_allocated_source_file(std::string* value);

  private:
  const std::string& _internal_source_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_file(
      const std::string& value);
  std::string* _internal_mutable_source_file();

  public:
  // bool enabled = 5 [json_name = "enabled"];
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.CronJob)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr schedule_;
    ::google::protobuf::internal::ArenaStringPtr command_;
    ::google::protobuf::internal::ArenaStringPtr user_;
    ::google::protobuf::internal::ArenaStringPtr source_file_;
    bool enabled_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class CpuMetrics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.CpuMetrics) */ {
 public:
  inline CpuMetrics() : CpuMetrics(nullptr) {}
  ~CpuMetrics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CpuMetrics(::google::protobuf::internal::ConstantInitialized);

  inline CpuMetrics(const CpuMetrics& from)
      : CpuMetrics(nullptr, from) {}
  CpuMetrics(CpuMetrics&& from) noexcept
    : CpuMetrics() {
    *this = ::std::move(from);
  }

  inline CpuMetrics& operator=(const CpuMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpuMetrics& operator=(CpuMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CpuMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const CpuMetrics* internal_default_instance() {
    return reinterpret_cast<const CpuMetrics*>(
               &_CpuMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CpuMetrics& a, CpuMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(CpuMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpuMetrics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CpuMetrics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CpuMetrics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CpuMetrics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CpuMetrics& from) {
    CpuMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CpuMetrics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.CpuMetrics";
  }
  protected:
  explicit CpuMetrics(::google::protobuf::Arena* arena);
  CpuMetrics(::google::protobuf::Arena* arena, const CpuMetrics& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerCoreFieldNumber = 3,
    kUsagePercentFieldNumber = 1,
    kLoad1MFieldNumber = 4,
    kLoad5MFieldNumber = 5,
    kLoad15MFieldNumber = 6,
    kCoresFieldNumber = 2,
  };
  // repeated double per_core = 3 [json_name = "perCore"];
  int per_core_size() const;
  private:
  int _internal_per_core_size() const;

  public:
  void clear_per_core() ;
  double per_core(int index) const;
  void set_per_core(int index, double value);
  void add_per_core(double value);
  const ::google::protobuf::RepeatedField<double>& per_core() const;
  ::google::protobuf::RepeatedField<double>* mutable_per_core();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_per_core() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_per_core();

  public:
  // double usage_percent = 1 [json_name = "usagePercent"];
  void clear_usage_percent() ;
  double usage_percent() const;
  void set_usage_percent(double value);

  private:
  double _internal_usage_percent() const;
  void _internal_set_usage_percent(double value);

  public:
  // double load_1m = 4 [json_name = "load1m"];
  void clear_load_1m() ;
  double load_1m() const;
  void set_load_1m(double value);

  private:
  double _internal_load_1m() const;
  void _internal_set_load_1m(double value);

  public:
  // double load_5m = 5 [json_name = "load5m"];
  void clear_load_5m() ;
  double load_5m() const;
  void set_load_5m(double value);

  private:
  double _internal_load_5m() const;
  void _internal_set_load_5m(double value);

  public:
  // double load_15m = 6 [json_name = "load15m"];
  void clear_load_15m() ;
  double load_15m() const;
  void set_load_15m(double value);

  private:
  double _internal_load_15m() const;
  void _internal_set_load_15m(double value);

  public:
  // int32 cores = 2 [json_name = "cores"];
  void clear_cores() ;
  ::int32_t cores() const;
  void set_cores(::int32_t value);

  private:
  ::int32_t _internal_cores() const;
  void _internal_set_cores(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.CpuMetrics)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> per_core_;
    double usage_percent_;
    double load_1m_;
    double load_5m_;
    double load_15m_;
    ::int32_t cores_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class SystemInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.SystemInfo) */ {
 public:
  inline SystemInfo() : SystemInfo(nullptr) {}
  ~SystemInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SystemInfo(::google::protobuf::internal::ConstantInitialized);

  inline SystemInfo(const SystemInfo& from)
      : SystemInfo(nullptr, from) {}
  SystemInfo(SystemInfo&& from) noexcept
    : SystemInfo() {
    *this = ::std::move(from);
  }

  inline SystemInfo& operator=(const SystemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemInfo& operator=(SystemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemInfo* internal_default_instance() {
    return reinterpret_cast<const SystemInfo*>(
               &_SystemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SystemInfo& a, SystemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SystemInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SystemInfo& from) {
    SystemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SystemInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.SystemInfo";
  }
  protected:
  explicit SystemInfo(::google::protobuf::Arena* arena);
  SystemInfo(::google::protobuf::Arena* arena, const SystemInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostnameFieldNumber = 1,
    kOsFieldNumber = 2,
    kOsVersionFieldNumber = 3,
    kKernelVersionFieldNumber = 4,
    kArchFieldNumber = 5,
    kAgentVersionFieldNumber = 9,
    kBootTimeFieldNumber = 8,
    kOpsStatusFieldNumber = 10,
    kTotalMemoryFieldNumber = 7,
    kCpuCoresFieldNumber = 6,
  };
  // string hostname = 1 [json_name = "hostname"];
  void clear_hostname() ;
  const std::string& hostname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hostname(Arg_&& arg, Args_... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* value);

  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(
      const std::string& value);
  std::string* _internal_mutable_hostname();

  public:
  // string os = 2 [json_name = "os"];
  void clear_os() ;
  const std::string& os() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_os(Arg_&& arg, Args_... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* value);

  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(
      const std::string& value);
  std::string* _internal_mutable_os();

  public:
  // string os_version = 3 [json_name = "osVersion"];
  void clear_os_version() ;
  const std::string& os_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_os_version(Arg_&& arg, Args_... args);
  std::string* mutable_os_version();
  PROTOBUF_NODISCARD std::string* release_os_version();
  void set_allocated_os_version(std::string* value);

  private:
  const std::string& _internal_os_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_version(
      const std::string& value);
  std::string* _internal_mutable_os_version();

  public:
  // string kernel_version = 4 [json_name = "kernelVersion"];
  void clear_kernel_version() ;
  const std::string& kernel_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_kernel_version(Arg_&& arg, Args_... args);
  std::string* mutable_kernel_version();
  PROTOBUF_NODISCARD std::string* release_kernel_version();
  void set_allocated_kernel_version(std::string* value);

  private:
  const std::string& _internal_kernel_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kernel_version(
      const std::string& value);
  std::string* _internal_mutable_kernel_version();

  public:
  // string arch = 5 [json_name = "arch"];
  void clear_arch() ;
  const std::string& arch() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_arch(Arg_&& arg, Args_... args);
  std::string* mutable_arch();
  PROTOBUF_NODISCARD std::string* release_arch();
  void set_allocated_arch(std::string* value);

  private:
  const std::string& _internal_arch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arch(
      const std::string& value);
  std::string* _internal_mutable_arch();

  public:
  // string agent_version = 9 [json_name = "agentVersion"];
  void clear_agent_version() ;
  const std::string& agent_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_version(Arg_&& arg, Args_... args);
  std::string* mutable_agent_version();
  PROTOBUF_NODISCARD std::string* release_agent_version();
  void set_allocated_agent_version(std::string* value);

  private:
  const std::string& _internal_agent_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_version(
      const std::string& value);
  std::string* _internal_mutable_agent_version();

  public:
  // .google.protobuf.Timestamp boot_time = 8 [json_name = "bootTime"];
  bool has_boot_time() const;
  void clear_boot_time() ;
  const ::google::protobuf::Timestamp& boot_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_boot_time();
  ::google::protobuf::Timestamp* mutable_boot_time();
  void set_allocated_boot_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_boot_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_boot_time();

  private:
  const ::google::protobuf::Timestamp& _internal_boot_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_boot_time();

  public:
  // .croupier.ops.v1.OpsStatus ops_status = 10 [json_name = "opsStatus"];
  bool has_ops_status() const;
  void clear_ops_status() ;
  const ::croupier::ops::v1::OpsStatus& ops_status() const;
  PROTOBUF_NODISCARD ::croupier::ops::v1::OpsStatus* release_ops_status();
  ::croupier::ops::v1::OpsStatus* mutable_ops_status();
  void set_allocated_ops_status(::croupier::ops::v1::OpsStatus* value);
  void unsafe_arena_set_allocated_ops_status(::croupier::ops::v1::OpsStatus* value);
  ::croupier::ops::v1::OpsStatus* unsafe_arena_release_ops_status();

  private:
  const ::croupier::ops::v1::OpsStatus& _internal_ops_status() const;
  ::croupier::ops::v1::OpsStatus* _internal_mutable_ops_status();

  public:
  // uint64 total_memory = 7 [json_name = "totalMemory"];
  void clear_total_memory() ;
  ::uint64_t total_memory() const;
  void set_total_memory(::uint64_t value);

  private:
  ::uint64_t _internal_total_memory() const;
  void _internal_set_total_memory(::uint64_t value);

  public:
  // int32 cpu_cores = 6 [json_name = "cpuCores"];
  void clear_cpu_cores() ;
  ::int32_t cpu_cores() const;
  void set_cpu_cores(::int32_t value);

  private:
  ::int32_t _internal_cpu_cores() const;
  void _internal_set_cpu_cores(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.SystemInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 2,
      94, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr hostname_;
    ::google::protobuf::internal::ArenaStringPtr os_;
    ::google::protobuf::internal::ArenaStringPtr os_version_;
    ::google::protobuf::internal::ArenaStringPtr kernel_version_;
    ::google::protobuf::internal::ArenaStringPtr arch_;
    ::google::protobuf::internal::ArenaStringPtr agent_version_;
    ::google::protobuf::Timestamp* boot_time_;
    ::croupier::ops::v1::OpsStatus* ops_status_;
    ::uint64_t total_memory_;
    ::int32_t cpu_cores_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class ProcessMetrics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.ProcessMetrics) */ {
 public:
  inline ProcessMetrics() : ProcessMetrics(nullptr) {}
  ~ProcessMetrics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProcessMetrics(::google::protobuf::internal::ConstantInitialized);

  inline ProcessMetrics(const ProcessMetrics& from)
      : ProcessMetrics(nullptr, from) {}
  ProcessMetrics(ProcessMetrics&& from) noexcept
    : ProcessMetrics() {
    *this = ::std::move(from);
  }

  inline ProcessMetrics& operator=(const ProcessMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessMetrics& operator=(ProcessMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessMetrics* internal_default_instance() {
    return reinterpret_cast<const ProcessMetrics*>(
               &_ProcessMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ProcessMetrics& a, ProcessMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessMetrics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessMetrics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessMetrics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProcessMetrics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProcessMetrics& from) {
    ProcessMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProcessMetrics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.ProcessMetrics";
  }
  protected:
  explicit ProcessMetrics(::google::protobuf::Arena* arena);
  ProcessMetrics(::google::protobuf::Arena* arena, const ProcessMetrics& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kStatusFieldNumber = 3,
    kStartTimeFieldNumber = 7,
    kPidFieldNumber = 1,
    kThreadsFieldNumber = 6,
    kCpuPercentFieldNumber = 4,
    kMemoryBytesFieldNumber = 5,
  };
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string status = 3 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // .google.protobuf.Timestamp start_time = 7 [json_name = "startTime"];
  bool has_start_time() const;
  void clear_start_time() ;
  const ::google::protobuf::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_start_time();
  ::google::protobuf::Timestamp* mutable_start_time();
  void set_allocated_start_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_start_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_start_time();

  private:
  const ::google::protobuf::Timestamp& _internal_start_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_start_time();

  public:
  // int32 pid = 1 [json_name = "pid"];
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // int32 threads = 6 [json_name = "threads"];
  void clear_threads() ;
  ::int32_t threads() const;
  void set_threads(::int32_t value);

  private:
  ::int32_t _internal_threads() const;
  void _internal_set_threads(::int32_t value);

  public:
  // double cpu_percent = 4 [json_name = "cpuPercent"];
  void clear_cpu_percent() ;
  double cpu_percent() const;
  void set_cpu_percent(double value);

  private:
  double _internal_cpu_percent() const;
  void _internal_set_cpu_percent(double value);

  public:
  // uint64 memory_bytes = 5 [json_name = "memoryBytes"];
  void clear_memory_bytes() ;
  ::uint64_t memory_bytes() const;
  void set_memory_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_memory_bytes() const;
  void _internal_set_memory_bytes(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.ProcessMetrics)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::Timestamp* start_time_;
    ::int32_t pid_;
    ::int32_t threads_;
    double cpu_percent_;
    ::uint64_t memory_bytes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class ManagedProcess final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.ManagedProcess) */ {
 public:
  inline ManagedProcess() : ManagedProcess(nullptr) {}
  ~ManagedProcess() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ManagedProcess(::google::protobuf::internal::ConstantInitialized);

  inline ManagedProcess(const ManagedProcess& from)
      : ManagedProcess(nullptr, from) {}
  ManagedProcess(ManagedProcess&& from) noexcept
    : ManagedProcess() {
    *this = ::std::move(from);
  }

  inline ManagedProcess& operator=(const ManagedProcess& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManagedProcess& operator=(ManagedProcess&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManagedProcess& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManagedProcess* internal_default_instance() {
    return reinterpret_cast<const ManagedProcess*>(
               &_ManagedProcess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ManagedProcess& a, ManagedProcess& b) {
    a.Swap(&b);
  }
  inline void Swap(ManagedProcess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManagedProcess* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManagedProcess* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManagedProcess>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ManagedProcess& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ManagedProcess& from) {
    ManagedProcess::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ManagedProcess* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.ManagedProcess";
  }
  protected:
  explicit ManagedProcess(::google::protobuf::Arena* arena);
  ManagedProcess(::google::protobuf::Arena* arena, const ManagedProcess& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCommandFieldNumber = 2,
    kWorkingDirFieldNumber = 3,
    kLastStartFieldNumber = 7,
    kStateFieldNumber = 4,
    kPidFieldNumber = 5,
    kRestartCountFieldNumber = 6,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string command = 2 [json_name = "command"];
  void clear_command() ;
  const std::string& command() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_command(Arg_&& arg, Args_... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* value);

  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(
      const std::string& value);
  std::string* _internal_mutable_command();

  public:
  // string working_dir = 3 [json_name = "workingDir"];
  void clear_working_dir() ;
  const std::string& working_dir() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_working_dir(Arg_&& arg, Args_... args);
  std::string* mutable_working_dir();
  PROTOBUF_NODISCARD std::string* release_working_dir();
  void set_allocated_working_dir(std::string* value);

  private:
  const std::string& _internal_working_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_working_dir(
      const std::string& value);
  std::string* _internal_mutable_working_dir();

  public:
  // .google.protobuf.Timestamp last_start = 7 [json_name = "lastStart"];
  bool has_last_start() const;
  void clear_last_start() ;
  const ::google::protobuf::Timestamp& last_start() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_start();
  ::google::protobuf::Timestamp* mutable_last_start();
  void set_allocated_last_start(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_start(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_start();

  private:
  const ::google::protobuf::Timestamp& _internal_last_start() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_start();

  public:
  // .croupier.ops.v1.ProcessState state = 4 [json_name = "state"];
  void clear_state() ;
  ::croupier::ops::v1::ProcessState state() const;
  void set_state(::croupier::ops::v1::ProcessState value);

  private:
  ::croupier::ops::v1::ProcessState _internal_state() const;
  void _internal_set_state(::croupier::ops::v1::ProcessState value);

  public:
  // int32 pid = 5 [json_name = "pid"];
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // int32 restart_count = 6 [json_name = "restartCount"];
  void clear_restart_count() ;
  ::int32_t restart_count() const;
  void set_restart_count(::int32_t value);

  private:
  ::int32_t _internal_restart_count() const;
  void _internal_set_restart_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.ManagedProcess)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr command_;
    ::google::protobuf::internal::ArenaStringPtr working_dir_;
    ::google::protobuf::Timestamp* last_start_;
    int state_;
    ::int32_t pid_;
    ::int32_t restart_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class ListServicesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.ListServicesResponse) */ {
 public:
  inline ListServicesResponse() : ListServicesResponse(nullptr) {}
  ~ListServicesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListServicesResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListServicesResponse(const ListServicesResponse& from)
      : ListServicesResponse(nullptr, from) {}
  ListServicesResponse(ListServicesResponse&& from) noexcept
    : ListServicesResponse() {
    *this = ::std::move(from);
  }

  inline ListServicesResponse& operator=(const ListServicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServicesResponse& operator=(ListServicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServicesResponse* internal_default_instance() {
    return reinterpret_cast<const ListServicesResponse*>(
               &_ListServicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ListServicesResponse& a, ListServicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServicesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServicesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServicesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListServicesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListServicesResponse& from) {
    ListServicesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListServicesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.ListServicesResponse";
  }
  protected:
  explicit ListServicesResponse(::google::protobuf::Arena* arena);
  ListServicesResponse(::google::protobuf::Arena* arena, const ListServicesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServicesFieldNumber = 1,
    kTotalFieldNumber = 2,
  };
  // repeated .croupier.ops.v1.ServiceInfo services = 1 [json_name = "services"];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::croupier::ops::v1::ServiceInfo* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::ServiceInfo >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ServiceInfo>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ServiceInfo>* _internal_mutable_services();
  public:
  const ::croupier::ops::v1::ServiceInfo& services(int index) const;
  ::croupier::ops::v1::ServiceInfo* add_services();
  const ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::ServiceInfo >&
      services() const;
  // int32 total = 2 [json_name = "total"];
  void clear_total() ;
  ::int32_t total() const;
  void set_total(::int32_t value);

  private:
  ::int32_t _internal_total() const;
  void _internal_set_total(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.ListServicesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::ServiceInfo > services_;
    ::int32_t total_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class ListCronJobsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.ListCronJobsResponse) */ {
 public:
  inline ListCronJobsResponse() : ListCronJobsResponse(nullptr) {}
  ~ListCronJobsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListCronJobsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListCronJobsResponse(const ListCronJobsResponse& from)
      : ListCronJobsResponse(nullptr, from) {}
  ListCronJobsResponse(ListCronJobsResponse&& from) noexcept
    : ListCronJobsResponse() {
    *this = ::std::move(from);
  }

  inline ListCronJobsResponse& operator=(const ListCronJobsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCronJobsResponse& operator=(ListCronJobsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListCronJobsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListCronJobsResponse* internal_default_instance() {
    return reinterpret_cast<const ListCronJobsResponse*>(
               &_ListCronJobsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ListCronJobsResponse& a, ListCronJobsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListCronJobsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCronJobsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListCronJobsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListCronJobsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListCronJobsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListCronJobsResponse& from) {
    ListCronJobsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListCronJobsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.ListCronJobsResponse";
  }
  protected:
  explicit ListCronJobsResponse(::google::protobuf::Arena* arena);
  ListCronJobsResponse(::google::protobuf::Arena* arena, const ListCronJobsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobsFieldNumber = 1,
    kTotalFieldNumber = 2,
  };
  // repeated .croupier.ops.v1.CronJob jobs = 1 [json_name = "jobs"];
  int jobs_size() const;
  private:
  int _internal_jobs_size() const;

  public:
  void clear_jobs() ;
  ::croupier::ops::v1::CronJob* mutable_jobs(int index);
  ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::CronJob >*
      mutable_jobs();
  private:
  const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::CronJob>& _internal_jobs() const;
  ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::CronJob>* _internal_mutable_jobs();
  public:
  const ::croupier::ops::v1::CronJob& jobs(int index) const;
  ::croupier::ops::v1::CronJob* add_jobs();
  const ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::CronJob >&
      jobs() const;
  // int32 total = 2 [json_name = "total"];
  void clear_total() ;
  ::int32_t total() const;
  void set_total(::int32_t value);

  private:
  ::int32_t _internal_total() const;
  void _internal_set_total(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.ListCronJobsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::CronJob > jobs_;
    ::int32_t total_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class ExecuteCommandRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.ExecuteCommandRequest) */ {
 public:
  inline ExecuteCommandRequest() : ExecuteCommandRequest(nullptr) {}
  ~ExecuteCommandRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExecuteCommandRequest(::google::protobuf::internal::ConstantInitialized);

  inline ExecuteCommandRequest(const ExecuteCommandRequest& from)
      : ExecuteCommandRequest(nullptr, from) {}
  ExecuteCommandRequest(ExecuteCommandRequest&& from) noexcept
    : ExecuteCommandRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteCommandRequest& operator=(const ExecuteCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteCommandRequest& operator=(ExecuteCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteCommandRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteCommandRequest*>(
               &_ExecuteCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ExecuteCommandRequest& a, ExecuteCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteCommandRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteCommandRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteCommandRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExecuteCommandRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ExecuteCommandRequest& from) {
    ExecuteCommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExecuteCommandRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.ExecuteCommandRequest";
  }
  protected:
  explicit ExecuteCommandRequest(::google::protobuf::Arena* arena);
  ExecuteCommandRequest(::google::protobuf::Arena* arena, const ExecuteCommandRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kEnvFieldNumber = 4,
    kCommandFieldNumber = 1,
    kWorkingDirFieldNumber = 3,
    kTimeoutSecondsFieldNumber = 5,
  };
  // repeated string args = 2 [json_name = "args"];
  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  void clear_args() ;
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, std::size_t size);
  void set_args(int index, absl::string_view value);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, std::size_t size);
  void add_args(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& args() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_args();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_args() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_args();

  public:
  // map<string, string> env = 4 [json_name = "env"];
  int env_size() const;
  private:
  int _internal_env_size() const;

  public:
  void clear_env() ;
  const ::google::protobuf::Map<std::string, std::string>& env() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_env();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_env() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_env();

  public:
  // string command = 1 [json_name = "command"];
  void clear_command() ;
  const std::string& command() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_command(Arg_&& arg, Args_... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* value);

  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(
      const std::string& value);
  std::string* _internal_mutable_command();

  public:
  // string working_dir = 3 [json_name = "workingDir"];
  void clear_working_dir() ;
  const std::string& working_dir() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_working_dir(Arg_&& arg, Args_... args);
  std::string* mutable_working_dir();
  PROTOBUF_NODISCARD std::string* release_working_dir();
  void set_allocated_working_dir(std::string* value);

  private:
  const std::string& _internal_working_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_working_dir(
      const std::string& value);
  std::string* _internal_mutable_working_dir();

  public:
  // int32 timeout_seconds = 5 [json_name = "timeoutSeconds"];
  void clear_timeout_seconds() ;
  ::int32_t timeout_seconds() const;
  void set_timeout_seconds(::int32_t value);

  private:
  ::int32_t _internal_timeout_seconds() const;
  void _internal_set_timeout_seconds(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.ExecuteCommandRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> args_;
    ::google::protobuf::internal::MapField<ExecuteCommandRequest_EnvEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        env_;
    ::google::protobuf::internal::ArenaStringPtr command_;
    ::google::protobuf::internal::ArenaStringPtr working_dir_;
    ::int32_t timeout_seconds_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class MetricsReport final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.MetricsReport) */ {
 public:
  inline MetricsReport() : MetricsReport(nullptr) {}
  ~MetricsReport() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MetricsReport(::google::protobuf::internal::ConstantInitialized);

  inline MetricsReport(const MetricsReport& from)
      : MetricsReport(nullptr, from) {}
  MetricsReport(MetricsReport&& from) noexcept
    : MetricsReport() {
    *this = ::std::move(from);
  }

  inline MetricsReport& operator=(const MetricsReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsReport& operator=(MetricsReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsReport* internal_default_instance() {
    return reinterpret_cast<const MetricsReport*>(
               &_MetricsReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MetricsReport& a, MetricsReport& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsReport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsReport* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsReport>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MetricsReport& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MetricsReport& from) {
    MetricsReport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MetricsReport* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.MetricsReport";
  }
  protected:
  explicit MetricsReport(::google::protobuf::Arena* arena);
  MetricsReport(::google::protobuf::Arena* arena, const MetricsReport& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDisksFieldNumber = 5,
    kNetworksFieldNumber = 6,
    kProcessesFieldNumber = 7,
    kCustomFieldNumber = 8,
    kAgentIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kCpuFieldNumber = 3,
    kMemoryFieldNumber = 4,
  };
  // repeated .croupier.ops.v1.DiskMetrics disks = 5 [json_name = "disks"];
  int disks_size() const;
  private:
  int _internal_disks_size() const;

  public:
  void clear_disks() ;
  ::croupier::ops::v1::DiskMetrics* mutable_disks(int index);
  ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::DiskMetrics >*
      mutable_disks();
  private:
  const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::DiskMetrics>& _internal_disks() const;
  ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::DiskMetrics>* _internal_mutable_disks();
  public:
  const ::croupier::ops::v1::DiskMetrics& disks(int index) const;
  ::croupier::ops::v1::DiskMetrics* add_disks();
  const ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::DiskMetrics >&
      disks() const;
  // repeated .croupier.ops.v1.NetworkMetrics networks = 6 [json_name = "networks"];
  int networks_size() const;
  private:
  int _internal_networks_size() const;

  public:
  void clear_networks() ;
  ::croupier::ops::v1::NetworkMetrics* mutable_networks(int index);
  ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::NetworkMetrics >*
      mutable_networks();
  private:
  const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::NetworkMetrics>& _internal_networks() const;
  ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::NetworkMetrics>* _internal_mutable_networks();
  public:
  const ::croupier::ops::v1::NetworkMetrics& networks(int index) const;
  ::croupier::ops::v1::NetworkMetrics* add_networks();
  const ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::NetworkMetrics >&
      networks() const;
  // repeated .croupier.ops.v1.ProcessMetrics processes = 7 [json_name = "processes"];
  int processes_size() const;
  private:
  int _internal_processes_size() const;

  public:
  void clear_processes() ;
  ::croupier::ops::v1::ProcessMetrics* mutable_processes(int index);
  ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::ProcessMetrics >*
      mutable_processes();
  private:
  const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ProcessMetrics>& _internal_processes() const;
  ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ProcessMetrics>* _internal_mutable_processes();
  public:
  const ::croupier::ops::v1::ProcessMetrics& processes(int index) const;
  ::croupier::ops::v1::ProcessMetrics* add_processes();
  const ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::ProcessMetrics >&
      processes() const;
  // map<string, double> custom = 8 [json_name = "custom"];
  int custom_size() const;
  private:
  int _internal_custom_size() const;

  public:
  void clear_custom() ;
  const ::google::protobuf::Map<std::string, double>& custom() const;
  ::google::protobuf::Map<std::string, double>* mutable_custom();

  private:
  const ::google::protobuf::Map<std::string, double>& _internal_custom() const;
  ::google::protobuf::Map<std::string, double>* _internal_mutable_custom();

  public:
  // string agent_id = 1 [json_name = "agentId"];
  void clear_agent_id() ;
  const std::string& agent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_id(Arg_&& arg, Args_... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* value);

  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(
      const std::string& value);
  std::string* _internal_mutable_agent_id();

  public:
  // .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // .croupier.ops.v1.CpuMetrics cpu = 3 [json_name = "cpu"];
  bool has_cpu() const;
  void clear_cpu() ;
  const ::croupier::ops::v1::CpuMetrics& cpu() const;
  PROTOBUF_NODISCARD ::croupier::ops::v1::CpuMetrics* release_cpu();
  ::croupier::ops::v1::CpuMetrics* mutable_cpu();
  void set_allocated_cpu(::croupier::ops::v1::CpuMetrics* value);
  void unsafe_arena_set_allocated_cpu(::croupier::ops::v1::CpuMetrics* value);
  ::croupier::ops::v1::CpuMetrics* unsafe_arena_release_cpu();

  private:
  const ::croupier::ops::v1::CpuMetrics& _internal_cpu() const;
  ::croupier::ops::v1::CpuMetrics* _internal_mutable_cpu();

  public:
  // .croupier.ops.v1.MemoryMetrics memory = 4 [json_name = "memory"];
  bool has_memory() const;
  void clear_memory() ;
  const ::croupier::ops::v1::MemoryMetrics& memory() const;
  PROTOBUF_NODISCARD ::croupier::ops::v1::MemoryMetrics* release_memory();
  ::croupier::ops::v1::MemoryMetrics* mutable_memory();
  void set_allocated_memory(::croupier::ops::v1::MemoryMetrics* value);
  void unsafe_arena_set_allocated_memory(::croupier::ops::v1::MemoryMetrics* value);
  ::croupier::ops::v1::MemoryMetrics* unsafe_arena_release_memory();

  private:
  const ::croupier::ops::v1::MemoryMetrics& _internal_memory() const;
  ::croupier::ops::v1::MemoryMetrics* _internal_mutable_memory();

  public:
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.MetricsReport)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 7,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::DiskMetrics > disks_;
    ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::NetworkMetrics > networks_;
    ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::ProcessMetrics > processes_;
    ::google::protobuf::internal::MapField<MetricsReport_CustomEntry_DoNotUse, std::string, double,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>
        custom_;
    ::google::protobuf::internal::ArenaStringPtr agent_id_;
    ::google::protobuf::Timestamp* timestamp_;
    ::croupier::ops::v1::CpuMetrics* cpu_;
    ::croupier::ops::v1::MemoryMetrics* memory_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};// -------------------------------------------------------------------

class ListProcessesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:croupier.ops.v1.ListProcessesResponse) */ {
 public:
  inline ListProcessesResponse() : ListProcessesResponse(nullptr) {}
  ~ListProcessesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListProcessesResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListProcessesResponse(const ListProcessesResponse& from)
      : ListProcessesResponse(nullptr, from) {}
  ListProcessesResponse(ListProcessesResponse&& from) noexcept
    : ListProcessesResponse() {
    *this = ::std::move(from);
  }

  inline ListProcessesResponse& operator=(const ListProcessesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProcessesResponse& operator=(ListProcessesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProcessesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProcessesResponse* internal_default_instance() {
    return reinterpret_cast<const ListProcessesResponse*>(
               &_ListProcessesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListProcessesResponse& a, ListProcessesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProcessesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProcessesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListProcessesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListProcessesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListProcessesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListProcessesResponse& from) {
    ListProcessesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListProcessesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "croupier.ops.v1.ListProcessesResponse";
  }
  protected:
  explicit ListProcessesResponse(::google::protobuf::Arena* arena);
  ListProcessesResponse(::google::protobuf::Arena* arena, const ListProcessesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessesFieldNumber = 1,
  };
  // repeated .croupier.ops.v1.ManagedProcess processes = 1 [json_name = "processes"];
  int processes_size() const;
  private:
  int _internal_processes_size() const;

  public:
  void clear_processes() ;
  ::croupier::ops::v1::ManagedProcess* mutable_processes(int index);
  ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::ManagedProcess >*
      mutable_processes();
  private:
  const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ManagedProcess>& _internal_processes() const;
  ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ManagedProcess>* _internal_mutable_processes();
  public:
  const ::croupier::ops::v1::ManagedProcess& processes(int index) const;
  ::croupier::ops::v1::ManagedProcess* add_processes();
  const ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::ManagedProcess >&
      processes() const;
  // @@protoc_insertion_point(class_scope:croupier.ops.v1.ListProcessesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::croupier::ops::v1::ManagedProcess > processes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_croupier_2fops_2fv1_2fops_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MetricsReport

// string agent_id = 1 [json_name = "agentId"];
inline void MetricsReport::clear_agent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& MetricsReport::agent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MetricsReport.agent_id)
  return _internal_agent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetricsReport::set_agent_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.MetricsReport.agent_id)
}
inline std::string* MetricsReport::mutable_agent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.MetricsReport.agent_id)
  return _s;
}
inline const std::string& MetricsReport::_internal_agent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.agent_id_.Get();
}
inline void MetricsReport::_internal_set_agent_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_id_.Set(value, GetArena());
}
inline std::string* MetricsReport::_internal_mutable_agent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.agent_id_.Mutable( GetArena());
}
inline std::string* MetricsReport::release_agent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.MetricsReport.agent_id)
  return _impl_.agent_id_.Release();
}
inline void MetricsReport::set_allocated_agent_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.agent_id_.IsDefault()) {
          _impl_.agent_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.MetricsReport.agent_id)
}

// .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp"];
inline bool MetricsReport::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& MetricsReport::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& MetricsReport::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MetricsReport.timestamp)
  return _internal_timestamp();
}
inline void MetricsReport::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.ops.v1.MetricsReport.timestamp)
}
inline ::google::protobuf::Timestamp* MetricsReport::release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* MetricsReport::unsafe_arena_release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.MetricsReport.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* MetricsReport::_internal_mutable_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* MetricsReport::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.MetricsReport.timestamp)
  return _msg;
}
inline void MetricsReport::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.MetricsReport.timestamp)
}

// .croupier.ops.v1.CpuMetrics cpu = 3 [json_name = "cpu"];
inline bool MetricsReport::has_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cpu_ != nullptr);
  return value;
}
inline void MetricsReport::clear_cpu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.cpu_ != nullptr) _impl_.cpu_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::croupier::ops::v1::CpuMetrics& MetricsReport::_internal_cpu() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::croupier::ops::v1::CpuMetrics* p = _impl_.cpu_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::ops::v1::CpuMetrics&>(::croupier::ops::v1::_CpuMetrics_default_instance_);
}
inline const ::croupier::ops::v1::CpuMetrics& MetricsReport::cpu() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MetricsReport.cpu)
  return _internal_cpu();
}
inline void MetricsReport::unsafe_arena_set_allocated_cpu(::croupier::ops::v1::CpuMetrics* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cpu_);
  }
  _impl_.cpu_ = reinterpret_cast<::croupier::ops::v1::CpuMetrics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.ops.v1.MetricsReport.cpu)
}
inline ::croupier::ops::v1::CpuMetrics* MetricsReport::release_cpu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::croupier::ops::v1::CpuMetrics* released = _impl_.cpu_;
  _impl_.cpu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::croupier::ops::v1::CpuMetrics* MetricsReport::unsafe_arena_release_cpu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.MetricsReport.cpu)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::croupier::ops::v1::CpuMetrics* temp = _impl_.cpu_;
  _impl_.cpu_ = nullptr;
  return temp;
}
inline ::croupier::ops::v1::CpuMetrics* MetricsReport::_internal_mutable_cpu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cpu_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::ops::v1::CpuMetrics>(GetArena());
    _impl_.cpu_ = reinterpret_cast<::croupier::ops::v1::CpuMetrics*>(p);
  }
  return _impl_.cpu_;
}
inline ::croupier::ops::v1::CpuMetrics* MetricsReport::mutable_cpu() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::croupier::ops::v1::CpuMetrics* _msg = _internal_mutable_cpu();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.MetricsReport.cpu)
  return _msg;
}
inline void MetricsReport::set_allocated_cpu(::croupier::ops::v1::CpuMetrics* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::croupier::ops::v1::CpuMetrics*>(_impl_.cpu_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::croupier::ops::v1::CpuMetrics*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cpu_ = reinterpret_cast<::croupier::ops::v1::CpuMetrics*>(value);
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.MetricsReport.cpu)
}

// .croupier.ops.v1.MemoryMetrics memory = 4 [json_name = "memory"];
inline bool MetricsReport::has_memory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.memory_ != nullptr);
  return value;
}
inline void MetricsReport::clear_memory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.memory_ != nullptr) _impl_.memory_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::croupier::ops::v1::MemoryMetrics& MetricsReport::_internal_memory() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::croupier::ops::v1::MemoryMetrics* p = _impl_.memory_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::ops::v1::MemoryMetrics&>(::croupier::ops::v1::_MemoryMetrics_default_instance_);
}
inline const ::croupier::ops::v1::MemoryMetrics& MetricsReport::memory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MetricsReport.memory)
  return _internal_memory();
}
inline void MetricsReport::unsafe_arena_set_allocated_memory(::croupier::ops::v1::MemoryMetrics* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_);
  }
  _impl_.memory_ = reinterpret_cast<::croupier::ops::v1::MemoryMetrics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.ops.v1.MetricsReport.memory)
}
inline ::croupier::ops::v1::MemoryMetrics* MetricsReport::release_memory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::croupier::ops::v1::MemoryMetrics* released = _impl_.memory_;
  _impl_.memory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::croupier::ops::v1::MemoryMetrics* MetricsReport::unsafe_arena_release_memory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.MetricsReport.memory)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::croupier::ops::v1::MemoryMetrics* temp = _impl_.memory_;
  _impl_.memory_ = nullptr;
  return temp;
}
inline ::croupier::ops::v1::MemoryMetrics* MetricsReport::_internal_mutable_memory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.memory_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::ops::v1::MemoryMetrics>(GetArena());
    _impl_.memory_ = reinterpret_cast<::croupier::ops::v1::MemoryMetrics*>(p);
  }
  return _impl_.memory_;
}
inline ::croupier::ops::v1::MemoryMetrics* MetricsReport::mutable_memory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::croupier::ops::v1::MemoryMetrics* _msg = _internal_mutable_memory();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.MetricsReport.memory)
  return _msg;
}
inline void MetricsReport::set_allocated_memory(::croupier::ops::v1::MemoryMetrics* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::croupier::ops::v1::MemoryMetrics*>(_impl_.memory_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::croupier::ops::v1::MemoryMetrics*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.memory_ = reinterpret_cast<::croupier::ops::v1::MemoryMetrics*>(value);
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.MetricsReport.memory)
}

// repeated .croupier.ops.v1.DiskMetrics disks = 5 [json_name = "disks"];
inline int MetricsReport::_internal_disks_size() const {
  return _internal_disks().size();
}
inline int MetricsReport::disks_size() const {
  return _internal_disks_size();
}
inline void MetricsReport::clear_disks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disks_.Clear();
}
inline ::croupier::ops::v1::DiskMetrics* MetricsReport::mutable_disks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.MetricsReport.disks)
  return _internal_mutable_disks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::DiskMetrics>* MetricsReport::mutable_disks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:croupier.ops.v1.MetricsReport.disks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_disks();
}
inline const ::croupier::ops::v1::DiskMetrics& MetricsReport::disks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MetricsReport.disks)
  return _internal_disks().Get(index);
}
inline ::croupier::ops::v1::DiskMetrics* MetricsReport::add_disks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::croupier::ops::v1::DiskMetrics* _add = _internal_mutable_disks()->Add();
  // @@protoc_insertion_point(field_add:croupier.ops.v1.MetricsReport.disks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::DiskMetrics>& MetricsReport::disks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:croupier.ops.v1.MetricsReport.disks)
  return _internal_disks();
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::DiskMetrics>&
MetricsReport::_internal_disks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disks_;
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::DiskMetrics>*
MetricsReport::_internal_mutable_disks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.disks_;
}

// repeated .croupier.ops.v1.NetworkMetrics networks = 6 [json_name = "networks"];
inline int MetricsReport::_internal_networks_size() const {
  return _internal_networks().size();
}
inline int MetricsReport::networks_size() const {
  return _internal_networks_size();
}
inline void MetricsReport::clear_networks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.networks_.Clear();
}
inline ::croupier::ops::v1::NetworkMetrics* MetricsReport::mutable_networks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.MetricsReport.networks)
  return _internal_mutable_networks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::NetworkMetrics>* MetricsReport::mutable_networks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:croupier.ops.v1.MetricsReport.networks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_networks();
}
inline const ::croupier::ops::v1::NetworkMetrics& MetricsReport::networks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MetricsReport.networks)
  return _internal_networks().Get(index);
}
inline ::croupier::ops::v1::NetworkMetrics* MetricsReport::add_networks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::croupier::ops::v1::NetworkMetrics* _add = _internal_mutable_networks()->Add();
  // @@protoc_insertion_point(field_add:croupier.ops.v1.MetricsReport.networks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::NetworkMetrics>& MetricsReport::networks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:croupier.ops.v1.MetricsReport.networks)
  return _internal_networks();
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::NetworkMetrics>&
MetricsReport::_internal_networks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.networks_;
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::NetworkMetrics>*
MetricsReport::_internal_mutable_networks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.networks_;
}

// repeated .croupier.ops.v1.ProcessMetrics processes = 7 [json_name = "processes"];
inline int MetricsReport::_internal_processes_size() const {
  return _internal_processes().size();
}
inline int MetricsReport::processes_size() const {
  return _internal_processes_size();
}
inline void MetricsReport::clear_processes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.processes_.Clear();
}
inline ::croupier::ops::v1::ProcessMetrics* MetricsReport::mutable_processes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.MetricsReport.processes)
  return _internal_mutable_processes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ProcessMetrics>* MetricsReport::mutable_processes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:croupier.ops.v1.MetricsReport.processes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_processes();
}
inline const ::croupier::ops::v1::ProcessMetrics& MetricsReport::processes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MetricsReport.processes)
  return _internal_processes().Get(index);
}
inline ::croupier::ops::v1::ProcessMetrics* MetricsReport::add_processes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::croupier::ops::v1::ProcessMetrics* _add = _internal_mutable_processes()->Add();
  // @@protoc_insertion_point(field_add:croupier.ops.v1.MetricsReport.processes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ProcessMetrics>& MetricsReport::processes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:croupier.ops.v1.MetricsReport.processes)
  return _internal_processes();
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ProcessMetrics>&
MetricsReport::_internal_processes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.processes_;
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ProcessMetrics>*
MetricsReport::_internal_mutable_processes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.processes_;
}

// map<string, double> custom = 8 [json_name = "custom"];
inline int MetricsReport::_internal_custom_size() const {
  return _internal_custom().size();
}
inline int MetricsReport::custom_size() const {
  return _internal_custom_size();
}
inline void MetricsReport::clear_custom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.custom_.Clear();
}
inline const ::google::protobuf::Map<std::string, double>& MetricsReport::_internal_custom() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.custom_.GetMap();
}
inline const ::google::protobuf::Map<std::string, double>& MetricsReport::custom() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:croupier.ops.v1.MetricsReport.custom)
  return _internal_custom();
}
inline ::google::protobuf::Map<std::string, double>* MetricsReport::_internal_mutable_custom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.custom_.MutableMap();
}
inline ::google::protobuf::Map<std::string, double>* MetricsReport::mutable_custom() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:croupier.ops.v1.MetricsReport.custom)
  return _internal_mutable_custom();
}

// -------------------------------------------------------------------

// CpuMetrics

// double usage_percent = 1 [json_name = "usagePercent"];
inline void CpuMetrics::clear_usage_percent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usage_percent_ = 0;
}
inline double CpuMetrics::usage_percent() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.CpuMetrics.usage_percent)
  return _internal_usage_percent();
}
inline void CpuMetrics::set_usage_percent(double value) {
  _internal_set_usage_percent(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.CpuMetrics.usage_percent)
}
inline double CpuMetrics::_internal_usage_percent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usage_percent_;
}
inline void CpuMetrics::_internal_set_usage_percent(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.usage_percent_ = value;
}

// int32 cores = 2 [json_name = "cores"];
inline void CpuMetrics::clear_cores() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cores_ = 0;
}
inline ::int32_t CpuMetrics::cores() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.CpuMetrics.cores)
  return _internal_cores();
}
inline void CpuMetrics::set_cores(::int32_t value) {
  _internal_set_cores(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.CpuMetrics.cores)
}
inline ::int32_t CpuMetrics::_internal_cores() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cores_;
}
inline void CpuMetrics::_internal_set_cores(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cores_ = value;
}

// repeated double per_core = 3 [json_name = "perCore"];
inline int CpuMetrics::_internal_per_core_size() const {
  return _internal_per_core().size();
}
inline int CpuMetrics::per_core_size() const {
  return _internal_per_core_size();
}
inline void CpuMetrics::clear_per_core() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.per_core_.Clear();
}
inline double CpuMetrics::per_core(int index) const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.CpuMetrics.per_core)
  return _internal_per_core().Get(index);
}
inline void CpuMetrics::set_per_core(int index, double value) {
  _internal_mutable_per_core()->Set(index, value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.CpuMetrics.per_core)
}
inline void CpuMetrics::add_per_core(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_per_core()->Add(value);
  // @@protoc_insertion_point(field_add:croupier.ops.v1.CpuMetrics.per_core)
}
inline const ::google::protobuf::RepeatedField<double>& CpuMetrics::per_core() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:croupier.ops.v1.CpuMetrics.per_core)
  return _internal_per_core();
}
inline ::google::protobuf::RepeatedField<double>* CpuMetrics::mutable_per_core()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:croupier.ops.v1.CpuMetrics.per_core)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_per_core();
}
inline const ::google::protobuf::RepeatedField<double>& CpuMetrics::_internal_per_core()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.per_core_;
}
inline ::google::protobuf::RepeatedField<double>* CpuMetrics::_internal_mutable_per_core() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.per_core_;
}

// double load_1m = 4 [json_name = "load1m"];
inline void CpuMetrics::clear_load_1m() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.load_1m_ = 0;
}
inline double CpuMetrics::load_1m() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.CpuMetrics.load_1m)
  return _internal_load_1m();
}
inline void CpuMetrics::set_load_1m(double value) {
  _internal_set_load_1m(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.CpuMetrics.load_1m)
}
inline double CpuMetrics::_internal_load_1m() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.load_1m_;
}
inline void CpuMetrics::_internal_set_load_1m(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.load_1m_ = value;
}

// double load_5m = 5 [json_name = "load5m"];
inline void CpuMetrics::clear_load_5m() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.load_5m_ = 0;
}
inline double CpuMetrics::load_5m() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.CpuMetrics.load_5m)
  return _internal_load_5m();
}
inline void CpuMetrics::set_load_5m(double value) {
  _internal_set_load_5m(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.CpuMetrics.load_5m)
}
inline double CpuMetrics::_internal_load_5m() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.load_5m_;
}
inline void CpuMetrics::_internal_set_load_5m(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.load_5m_ = value;
}

// double load_15m = 6 [json_name = "load15m"];
inline void CpuMetrics::clear_load_15m() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.load_15m_ = 0;
}
inline double CpuMetrics::load_15m() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.CpuMetrics.load_15m)
  return _internal_load_15m();
}
inline void CpuMetrics::set_load_15m(double value) {
  _internal_set_load_15m(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.CpuMetrics.load_15m)
}
inline double CpuMetrics::_internal_load_15m() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.load_15m_;
}
inline void CpuMetrics::_internal_set_load_15m(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.load_15m_ = value;
}

// -------------------------------------------------------------------

// MemoryMetrics

// uint64 total_bytes = 1 [json_name = "totalBytes"];
inline void MemoryMetrics::clear_total_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t MemoryMetrics::total_bytes() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MemoryMetrics.total_bytes)
  return _internal_total_bytes();
}
inline void MemoryMetrics::set_total_bytes(::uint64_t value) {
  _internal_set_total_bytes(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.MemoryMetrics.total_bytes)
}
inline ::uint64_t MemoryMetrics::_internal_total_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_bytes_;
}
inline void MemoryMetrics::_internal_set_total_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_bytes_ = value;
}

// uint64 used_bytes = 2 [json_name = "usedBytes"];
inline void MemoryMetrics::clear_used_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.used_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t MemoryMetrics::used_bytes() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MemoryMetrics.used_bytes)
  return _internal_used_bytes();
}
inline void MemoryMetrics::set_used_bytes(::uint64_t value) {
  _internal_set_used_bytes(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.MemoryMetrics.used_bytes)
}
inline ::uint64_t MemoryMetrics::_internal_used_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.used_bytes_;
}
inline void MemoryMetrics::_internal_set_used_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.used_bytes_ = value;
}

// uint64 available_bytes = 3 [json_name = "availableBytes"];
inline void MemoryMetrics::clear_available_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.available_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t MemoryMetrics::available_bytes() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MemoryMetrics.available_bytes)
  return _internal_available_bytes();
}
inline void MemoryMetrics::set_available_bytes(::uint64_t value) {
  _internal_set_available_bytes(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.MemoryMetrics.available_bytes)
}
inline ::uint64_t MemoryMetrics::_internal_available_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.available_bytes_;
}
inline void MemoryMetrics::_internal_set_available_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.available_bytes_ = value;
}

// double usage_percent = 4 [json_name = "usagePercent"];
inline void MemoryMetrics::clear_usage_percent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usage_percent_ = 0;
}
inline double MemoryMetrics::usage_percent() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MemoryMetrics.usage_percent)
  return _internal_usage_percent();
}
inline void MemoryMetrics::set_usage_percent(double value) {
  _internal_set_usage_percent(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.MemoryMetrics.usage_percent)
}
inline double MemoryMetrics::_internal_usage_percent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usage_percent_;
}
inline void MemoryMetrics::_internal_set_usage_percent(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.usage_percent_ = value;
}

// uint64 swap_total = 5 [json_name = "swapTotal"];
inline void MemoryMetrics::clear_swap_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.swap_total_ = ::uint64_t{0u};
}
inline ::uint64_t MemoryMetrics::swap_total() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MemoryMetrics.swap_total)
  return _internal_swap_total();
}
inline void MemoryMetrics::set_swap_total(::uint64_t value) {
  _internal_set_swap_total(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.MemoryMetrics.swap_total)
}
inline ::uint64_t MemoryMetrics::_internal_swap_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.swap_total_;
}
inline void MemoryMetrics::_internal_set_swap_total(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.swap_total_ = value;
}

// uint64 swap_used = 6 [json_name = "swapUsed"];
inline void MemoryMetrics::clear_swap_used() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.swap_used_ = ::uint64_t{0u};
}
inline ::uint64_t MemoryMetrics::swap_used() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.MemoryMetrics.swap_used)
  return _internal_swap_used();
}
inline void MemoryMetrics::set_swap_used(::uint64_t value) {
  _internal_set_swap_used(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.MemoryMetrics.swap_used)
}
inline ::uint64_t MemoryMetrics::_internal_swap_used() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.swap_used_;
}
inline void MemoryMetrics::_internal_set_swap_used(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.swap_used_ = value;
}

// -------------------------------------------------------------------

// DiskMetrics

// string mount_point = 1 [json_name = "mountPoint"];
inline void DiskMetrics::clear_mount_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mount_point_.ClearToEmpty();
}
inline const std::string& DiskMetrics::mount_point() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.DiskMetrics.mount_point)
  return _internal_mount_point();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DiskMetrics::set_mount_point(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mount_point_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.DiskMetrics.mount_point)
}
inline std::string* DiskMetrics::mutable_mount_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mount_point();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.DiskMetrics.mount_point)
  return _s;
}
inline const std::string& DiskMetrics::_internal_mount_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mount_point_.Get();
}
inline void DiskMetrics::_internal_set_mount_point(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mount_point_.Set(value, GetArena());
}
inline std::string* DiskMetrics::_internal_mutable_mount_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mount_point_.Mutable( GetArena());
}
inline std::string* DiskMetrics::release_mount_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.DiskMetrics.mount_point)
  return _impl_.mount_point_.Release();
}
inline void DiskMetrics::set_allocated_mount_point(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mount_point_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mount_point_.IsDefault()) {
          _impl_.mount_point_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.DiskMetrics.mount_point)
}

// string device = 2 [json_name = "device"];
inline void DiskMetrics::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& DiskMetrics::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.DiskMetrics.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DiskMetrics::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.DiskMetrics.device)
}
inline std::string* DiskMetrics::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.DiskMetrics.device)
  return _s;
}
inline const std::string& DiskMetrics::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void DiskMetrics::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* DiskMetrics::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* DiskMetrics::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.DiskMetrics.device)
  return _impl_.device_.Release();
}
inline void DiskMetrics::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.DiskMetrics.device)
}

// string fs_type = 3 [json_name = "fsType"];
inline void DiskMetrics::clear_fs_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fs_type_.ClearToEmpty();
}
inline const std::string& DiskMetrics::fs_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.DiskMetrics.fs_type)
  return _internal_fs_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DiskMetrics::set_fs_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fs_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.DiskMetrics.fs_type)
}
inline std::string* DiskMetrics::mutable_fs_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fs_type();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.DiskMetrics.fs_type)
  return _s;
}
inline const std::string& DiskMetrics::_internal_fs_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fs_type_.Get();
}
inline void DiskMetrics::_internal_set_fs_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fs_type_.Set(value, GetArena());
}
inline std::string* DiskMetrics::_internal_mutable_fs_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.fs_type_.Mutable( GetArena());
}
inline std::string* DiskMetrics::release_fs_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.DiskMetrics.fs_type)
  return _impl_.fs_type_.Release();
}
inline void DiskMetrics::set_allocated_fs_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fs_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fs_type_.IsDefault()) {
          _impl_.fs_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.DiskMetrics.fs_type)
}

// uint64 total_bytes = 4 [json_name = "totalBytes"];
inline void DiskMetrics::clear_total_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t DiskMetrics::total_bytes() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.DiskMetrics.total_bytes)
  return _internal_total_bytes();
}
inline void DiskMetrics::set_total_bytes(::uint64_t value) {
  _internal_set_total_bytes(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.DiskMetrics.total_bytes)
}
inline ::uint64_t DiskMetrics::_internal_total_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_bytes_;
}
inline void DiskMetrics::_internal_set_total_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_bytes_ = value;
}

// uint64 used_bytes = 5 [json_name = "usedBytes"];
inline void DiskMetrics::clear_used_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.used_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t DiskMetrics::used_bytes() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.DiskMetrics.used_bytes)
  return _internal_used_bytes();
}
inline void DiskMetrics::set_used_bytes(::uint64_t value) {
  _internal_set_used_bytes(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.DiskMetrics.used_bytes)
}
inline ::uint64_t DiskMetrics::_internal_used_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.used_bytes_;
}
inline void DiskMetrics::_internal_set_used_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.used_bytes_ = value;
}

// uint64 available_bytes = 6 [json_name = "availableBytes"];
inline void DiskMetrics::clear_available_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.available_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t DiskMetrics::available_bytes() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.DiskMetrics.available_bytes)
  return _internal_available_bytes();
}
inline void DiskMetrics::set_available_bytes(::uint64_t value) {
  _internal_set_available_bytes(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.DiskMetrics.available_bytes)
}
inline ::uint64_t DiskMetrics::_internal_available_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.available_bytes_;
}
inline void DiskMetrics::_internal_set_available_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.available_bytes_ = value;
}

// double usage_percent = 7 [json_name = "usagePercent"];
inline void DiskMetrics::clear_usage_percent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usage_percent_ = 0;
}
inline double DiskMetrics::usage_percent() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.DiskMetrics.usage_percent)
  return _internal_usage_percent();
}
inline void DiskMetrics::set_usage_percent(double value) {
  _internal_set_usage_percent(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.DiskMetrics.usage_percent)
}
inline double DiskMetrics::_internal_usage_percent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usage_percent_;
}
inline void DiskMetrics::_internal_set_usage_percent(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.usage_percent_ = value;
}

// uint64 inode_total = 8 [json_name = "inodeTotal"];
inline void DiskMetrics::clear_inode_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inode_total_ = ::uint64_t{0u};
}
inline ::uint64_t DiskMetrics::inode_total() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.DiskMetrics.inode_total)
  return _internal_inode_total();
}
inline void DiskMetrics::set_inode_total(::uint64_t value) {
  _internal_set_inode_total(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.DiskMetrics.inode_total)
}
inline ::uint64_t DiskMetrics::_internal_inode_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inode_total_;
}
inline void DiskMetrics::_internal_set_inode_total(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.inode_total_ = value;
}

// uint64 inode_used = 9 [json_name = "inodeUsed"];
inline void DiskMetrics::clear_inode_used() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inode_used_ = ::uint64_t{0u};
}
inline ::uint64_t DiskMetrics::inode_used() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.DiskMetrics.inode_used)
  return _internal_inode_used();
}
inline void DiskMetrics::set_inode_used(::uint64_t value) {
  _internal_set_inode_used(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.DiskMetrics.inode_used)
}
inline ::uint64_t DiskMetrics::_internal_inode_used() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inode_used_;
}
inline void DiskMetrics::_internal_set_inode_used(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.inode_used_ = value;
}

// -------------------------------------------------------------------

// NetworkMetrics

// string interface = 1 [json_name = "interface"];
inline void NetworkMetrics::clear_interface() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interface_.ClearToEmpty();
}
inline const std::string& NetworkMetrics::interface() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.NetworkMetrics.interface)
  return _internal_interface();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkMetrics::set_interface(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interface_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.NetworkMetrics.interface)
}
inline std::string* NetworkMetrics::mutable_interface() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interface();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.NetworkMetrics.interface)
  return _s;
}
inline const std::string& NetworkMetrics::_internal_interface() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interface_.Get();
}
inline void NetworkMetrics::_internal_set_interface(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interface_.Set(value, GetArena());
}
inline std::string* NetworkMetrics::_internal_mutable_interface() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.interface_.Mutable( GetArena());
}
inline std::string* NetworkMetrics::release_interface() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.NetworkMetrics.interface)
  return _impl_.interface_.Release();
}
inline void NetworkMetrics::set_allocated_interface(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interface_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interface_.IsDefault()) {
          _impl_.interface_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.NetworkMetrics.interface)
}

// uint64 bytes_sent = 2 [json_name = "bytesSent"];
inline void NetworkMetrics::clear_bytes_sent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bytes_sent_ = ::uint64_t{0u};
}
inline ::uint64_t NetworkMetrics::bytes_sent() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.NetworkMetrics.bytes_sent)
  return _internal_bytes_sent();
}
inline void NetworkMetrics::set_bytes_sent(::uint64_t value) {
  _internal_set_bytes_sent(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.NetworkMetrics.bytes_sent)
}
inline ::uint64_t NetworkMetrics::_internal_bytes_sent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bytes_sent_;
}
inline void NetworkMetrics::_internal_set_bytes_sent(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bytes_sent_ = value;
}

// uint64 bytes_recv = 3 [json_name = "bytesRecv"];
inline void NetworkMetrics::clear_bytes_recv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bytes_recv_ = ::uint64_t{0u};
}
inline ::uint64_t NetworkMetrics::bytes_recv() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.NetworkMetrics.bytes_recv)
  return _internal_bytes_recv();
}
inline void NetworkMetrics::set_bytes_recv(::uint64_t value) {
  _internal_set_bytes_recv(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.NetworkMetrics.bytes_recv)
}
inline ::uint64_t NetworkMetrics::_internal_bytes_recv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bytes_recv_;
}
inline void NetworkMetrics::_internal_set_bytes_recv(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bytes_recv_ = value;
}

// uint64 packets_sent = 4 [json_name = "packetsSent"];
inline void NetworkMetrics::clear_packets_sent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packets_sent_ = ::uint64_t{0u};
}
inline ::uint64_t NetworkMetrics::packets_sent() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.NetworkMetrics.packets_sent)
  return _internal_packets_sent();
}
inline void NetworkMetrics::set_packets_sent(::uint64_t value) {
  _internal_set_packets_sent(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.NetworkMetrics.packets_sent)
}
inline ::uint64_t NetworkMetrics::_internal_packets_sent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packets_sent_;
}
inline void NetworkMetrics::_internal_set_packets_sent(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.packets_sent_ = value;
}

// uint64 packets_recv = 5 [json_name = "packetsRecv"];
inline void NetworkMetrics::clear_packets_recv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packets_recv_ = ::uint64_t{0u};
}
inline ::uint64_t NetworkMetrics::packets_recv() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.NetworkMetrics.packets_recv)
  return _internal_packets_recv();
}
inline void NetworkMetrics::set_packets_recv(::uint64_t value) {
  _internal_set_packets_recv(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.NetworkMetrics.packets_recv)
}
inline ::uint64_t NetworkMetrics::_internal_packets_recv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packets_recv_;
}
inline void NetworkMetrics::_internal_set_packets_recv(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.packets_recv_ = value;
}

// uint64 errors_in = 6 [json_name = "errorsIn"];
inline void NetworkMetrics::clear_errors_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errors_in_ = ::uint64_t{0u};
}
inline ::uint64_t NetworkMetrics::errors_in() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.NetworkMetrics.errors_in)
  return _internal_errors_in();
}
inline void NetworkMetrics::set_errors_in(::uint64_t value) {
  _internal_set_errors_in(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.NetworkMetrics.errors_in)
}
inline ::uint64_t NetworkMetrics::_internal_errors_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.errors_in_;
}
inline void NetworkMetrics::_internal_set_errors_in(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.errors_in_ = value;
}

// uint64 errors_out = 7 [json_name = "errorsOut"];
inline void NetworkMetrics::clear_errors_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errors_out_ = ::uint64_t{0u};
}
inline ::uint64_t NetworkMetrics::errors_out() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.NetworkMetrics.errors_out)
  return _internal_errors_out();
}
inline void NetworkMetrics::set_errors_out(::uint64_t value) {
  _internal_set_errors_out(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.NetworkMetrics.errors_out)
}
inline ::uint64_t NetworkMetrics::_internal_errors_out() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.errors_out_;
}
inline void NetworkMetrics::_internal_set_errors_out(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.errors_out_ = value;
}

// -------------------------------------------------------------------

// ProcessMetrics

// int32 pid = 1 [json_name = "pid"];
inline void ProcessMetrics::clear_pid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pid_ = 0;
}
inline ::int32_t ProcessMetrics::pid() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ProcessMetrics.pid)
  return _internal_pid();
}
inline void ProcessMetrics::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ProcessMetrics.pid)
}
inline ::int32_t ProcessMetrics::_internal_pid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pid_;
}
inline void ProcessMetrics::_internal_set_pid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pid_ = value;
}

// string name = 2 [json_name = "name"];
inline void ProcessMetrics::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ProcessMetrics::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ProcessMetrics.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcessMetrics::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ProcessMetrics.name)
}
inline std::string* ProcessMetrics::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ProcessMetrics.name)
  return _s;
}
inline const std::string& ProcessMetrics::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ProcessMetrics::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ProcessMetrics::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ProcessMetrics::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ProcessMetrics.name)
  return _impl_.name_.Release();
}
inline void ProcessMetrics::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ProcessMetrics.name)
}

// string status = 3 [json_name = "status"];
inline void ProcessMetrics::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ProcessMetrics::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ProcessMetrics.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcessMetrics::set_status(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ProcessMetrics.status)
}
inline std::string* ProcessMetrics::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ProcessMetrics.status)
  return _s;
}
inline const std::string& ProcessMetrics::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_.Get();
}
inline void ProcessMetrics::_internal_set_status(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_.Set(value, GetArena());
}
inline std::string* ProcessMetrics::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* ProcessMetrics::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ProcessMetrics.status)
  return _impl_.status_.Release();
}
inline void ProcessMetrics::set_allocated_status(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ProcessMetrics.status)
}

// double cpu_percent = 4 [json_name = "cpuPercent"];
inline void ProcessMetrics::clear_cpu_percent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cpu_percent_ = 0;
}
inline double ProcessMetrics::cpu_percent() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ProcessMetrics.cpu_percent)
  return _internal_cpu_percent();
}
inline void ProcessMetrics::set_cpu_percent(double value) {
  _internal_set_cpu_percent(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ProcessMetrics.cpu_percent)
}
inline double ProcessMetrics::_internal_cpu_percent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cpu_percent_;
}
inline void ProcessMetrics::_internal_set_cpu_percent(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cpu_percent_ = value;
}

// uint64 memory_bytes = 5 [json_name = "memoryBytes"];
inline void ProcessMetrics::clear_memory_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.memory_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t ProcessMetrics::memory_bytes() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ProcessMetrics.memory_bytes)
  return _internal_memory_bytes();
}
inline void ProcessMetrics::set_memory_bytes(::uint64_t value) {
  _internal_set_memory_bytes(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ProcessMetrics.memory_bytes)
}
inline ::uint64_t ProcessMetrics::_internal_memory_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.memory_bytes_;
}
inline void ProcessMetrics::_internal_set_memory_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.memory_bytes_ = value;
}

// int32 threads = 6 [json_name = "threads"];
inline void ProcessMetrics::clear_threads() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.threads_ = 0;
}
inline ::int32_t ProcessMetrics::threads() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ProcessMetrics.threads)
  return _internal_threads();
}
inline void ProcessMetrics::set_threads(::int32_t value) {
  _internal_set_threads(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ProcessMetrics.threads)
}
inline ::int32_t ProcessMetrics::_internal_threads() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.threads_;
}
inline void ProcessMetrics::_internal_set_threads(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.threads_ = value;
}

// .google.protobuf.Timestamp start_time = 7 [json_name = "startTime"];
inline bool ProcessMetrics::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& ProcessMetrics::_internal_start_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& ProcessMetrics::start_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ProcessMetrics.start_time)
  return _internal_start_time();
}
inline void ProcessMetrics::unsafe_arena_set_allocated_start_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.ops.v1.ProcessMetrics.start_time)
}
inline ::google::protobuf::Timestamp* ProcessMetrics::release_start_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* ProcessMetrics::unsafe_arena_release_start_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ProcessMetrics.start_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ProcessMetrics::_internal_mutable_start_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.start_time_;
}
inline ::google::protobuf::Timestamp* ProcessMetrics::mutable_start_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ProcessMetrics.start_time)
  return _msg;
}
inline void ProcessMetrics::set_allocated_start_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ProcessMetrics.start_time)
}

// -------------------------------------------------------------------

// SystemInfo

// string hostname = 1 [json_name = "hostname"];
inline void SystemInfo::clear_hostname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& SystemInfo::hostname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.SystemInfo.hostname)
  return _internal_hostname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SystemInfo::set_hostname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hostname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.SystemInfo.hostname)
}
inline std::string* SystemInfo::mutable_hostname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.SystemInfo.hostname)
  return _s;
}
inline const std::string& SystemInfo::_internal_hostname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hostname_.Get();
}
inline void SystemInfo::_internal_set_hostname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hostname_.Set(value, GetArena());
}
inline std::string* SystemInfo::_internal_mutable_hostname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.hostname_.Mutable( GetArena());
}
inline std::string* SystemInfo::release_hostname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.SystemInfo.hostname)
  return _impl_.hostname_.Release();
}
inline void SystemInfo::set_allocated_hostname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hostname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hostname_.IsDefault()) {
          _impl_.hostname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.SystemInfo.hostname)
}

// string os = 2 [json_name = "os"];
inline void SystemInfo::clear_os() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.os_.ClearToEmpty();
}
inline const std::string& SystemInfo::os() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.SystemInfo.os)
  return _internal_os();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SystemInfo::set_os(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.os_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.SystemInfo.os)
}
inline std::string* SystemInfo::mutable_os() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.SystemInfo.os)
  return _s;
}
inline const std::string& SystemInfo::_internal_os() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.os_.Get();
}
inline void SystemInfo::_internal_set_os(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.os_.Set(value, GetArena());
}
inline std::string* SystemInfo::_internal_mutable_os() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.os_.Mutable( GetArena());
}
inline std::string* SystemInfo::release_os() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.SystemInfo.os)
  return _impl_.os_.Release();
}
inline void SystemInfo::set_allocated_os(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.os_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.os_.IsDefault()) {
          _impl_.os_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.SystemInfo.os)
}

// string os_version = 3 [json_name = "osVersion"];
inline void SystemInfo::clear_os_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.os_version_.ClearToEmpty();
}
inline const std::string& SystemInfo::os_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.SystemInfo.os_version)
  return _internal_os_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SystemInfo::set_os_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.os_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.SystemInfo.os_version)
}
inline std::string* SystemInfo::mutable_os_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_os_version();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.SystemInfo.os_version)
  return _s;
}
inline const std::string& SystemInfo::_internal_os_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.os_version_.Get();
}
inline void SystemInfo::_internal_set_os_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.os_version_.Set(value, GetArena());
}
inline std::string* SystemInfo::_internal_mutable_os_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.os_version_.Mutable( GetArena());
}
inline std::string* SystemInfo::release_os_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.SystemInfo.os_version)
  return _impl_.os_version_.Release();
}
inline void SystemInfo::set_allocated_os_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.os_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.os_version_.IsDefault()) {
          _impl_.os_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.SystemInfo.os_version)
}

// string kernel_version = 4 [json_name = "kernelVersion"];
inline void SystemInfo::clear_kernel_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kernel_version_.ClearToEmpty();
}
inline const std::string& SystemInfo::kernel_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.SystemInfo.kernel_version)
  return _internal_kernel_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SystemInfo::set_kernel_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kernel_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.SystemInfo.kernel_version)
}
inline std::string* SystemInfo::mutable_kernel_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_kernel_version();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.SystemInfo.kernel_version)
  return _s;
}
inline const std::string& SystemInfo::_internal_kernel_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kernel_version_.Get();
}
inline void SystemInfo::_internal_set_kernel_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kernel_version_.Set(value, GetArena());
}
inline std::string* SystemInfo::_internal_mutable_kernel_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.kernel_version_.Mutable( GetArena());
}
inline std::string* SystemInfo::release_kernel_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.SystemInfo.kernel_version)
  return _impl_.kernel_version_.Release();
}
inline void SystemInfo::set_allocated_kernel_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kernel_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.kernel_version_.IsDefault()) {
          _impl_.kernel_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.SystemInfo.kernel_version)
}

// string arch = 5 [json_name = "arch"];
inline void SystemInfo::clear_arch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arch_.ClearToEmpty();
}
inline const std::string& SystemInfo::arch() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.SystemInfo.arch)
  return _internal_arch();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SystemInfo::set_arch(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.arch_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.SystemInfo.arch)
}
inline std::string* SystemInfo::mutable_arch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_arch();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.SystemInfo.arch)
  return _s;
}
inline const std::string& SystemInfo::_internal_arch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arch_.Get();
}
inline void SystemInfo::_internal_set_arch(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.arch_.Set(value, GetArena());
}
inline std::string* SystemInfo::_internal_mutable_arch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.arch_.Mutable( GetArena());
}
inline std::string* SystemInfo::release_arch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.SystemInfo.arch)
  return _impl_.arch_.Release();
}
inline void SystemInfo::set_allocated_arch(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arch_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.arch_.IsDefault()) {
          _impl_.arch_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.SystemInfo.arch)
}

// int32 cpu_cores = 6 [json_name = "cpuCores"];
inline void SystemInfo::clear_cpu_cores() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cpu_cores_ = 0;
}
inline ::int32_t SystemInfo::cpu_cores() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.SystemInfo.cpu_cores)
  return _internal_cpu_cores();
}
inline void SystemInfo::set_cpu_cores(::int32_t value) {
  _internal_set_cpu_cores(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.SystemInfo.cpu_cores)
}
inline ::int32_t SystemInfo::_internal_cpu_cores() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cpu_cores_;
}
inline void SystemInfo::_internal_set_cpu_cores(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cpu_cores_ = value;
}

// uint64 total_memory = 7 [json_name = "totalMemory"];
inline void SystemInfo::clear_total_memory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_memory_ = ::uint64_t{0u};
}
inline ::uint64_t SystemInfo::total_memory() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.SystemInfo.total_memory)
  return _internal_total_memory();
}
inline void SystemInfo::set_total_memory(::uint64_t value) {
  _internal_set_total_memory(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.SystemInfo.total_memory)
}
inline ::uint64_t SystemInfo::_internal_total_memory() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_memory_;
}
inline void SystemInfo::_internal_set_total_memory(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_memory_ = value;
}

// .google.protobuf.Timestamp boot_time = 8 [json_name = "bootTime"];
inline bool SystemInfo::has_boot_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.boot_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& SystemInfo::_internal_boot_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.boot_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& SystemInfo::boot_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.SystemInfo.boot_time)
  return _internal_boot_time();
}
inline void SystemInfo::unsafe_arena_set_allocated_boot_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.boot_time_);
  }
  _impl_.boot_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.ops.v1.SystemInfo.boot_time)
}
inline ::google::protobuf::Timestamp* SystemInfo::release_boot_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.boot_time_;
  _impl_.boot_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* SystemInfo::unsafe_arena_release_boot_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.SystemInfo.boot_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.boot_time_;
  _impl_.boot_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* SystemInfo::_internal_mutable_boot_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.boot_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.boot_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.boot_time_;
}
inline ::google::protobuf::Timestamp* SystemInfo::mutable_boot_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_boot_time();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.SystemInfo.boot_time)
  return _msg;
}
inline void SystemInfo::set_allocated_boot_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.boot_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.boot_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.SystemInfo.boot_time)
}

// string agent_version = 9 [json_name = "agentVersion"];
inline void SystemInfo::clear_agent_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_version_.ClearToEmpty();
}
inline const std::string& SystemInfo::agent_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.SystemInfo.agent_version)
  return _internal_agent_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SystemInfo::set_agent_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.SystemInfo.agent_version)
}
inline std::string* SystemInfo::mutable_agent_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_version();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.SystemInfo.agent_version)
  return _s;
}
inline const std::string& SystemInfo::_internal_agent_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.agent_version_.Get();
}
inline void SystemInfo::_internal_set_agent_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_version_.Set(value, GetArena());
}
inline std::string* SystemInfo::_internal_mutable_agent_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.agent_version_.Mutable( GetArena());
}
inline std::string* SystemInfo::release_agent_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.SystemInfo.agent_version)
  return _impl_.agent_version_.Release();
}
inline void SystemInfo::set_allocated_agent_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.agent_version_.IsDefault()) {
          _impl_.agent_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.SystemInfo.agent_version)
}

// .croupier.ops.v1.OpsStatus ops_status = 10 [json_name = "opsStatus"];
inline bool SystemInfo::has_ops_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ops_status_ != nullptr);
  return value;
}
inline void SystemInfo::clear_ops_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ops_status_ != nullptr) _impl_.ops_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::croupier::ops::v1::OpsStatus& SystemInfo::_internal_ops_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::croupier::ops::v1::OpsStatus* p = _impl_.ops_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::croupier::ops::v1::OpsStatus&>(::croupier::ops::v1::_OpsStatus_default_instance_);
}
inline const ::croupier::ops::v1::OpsStatus& SystemInfo::ops_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.SystemInfo.ops_status)
  return _internal_ops_status();
}
inline void SystemInfo::unsafe_arena_set_allocated_ops_status(::croupier::ops::v1::OpsStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ops_status_);
  }
  _impl_.ops_status_ = reinterpret_cast<::croupier::ops::v1::OpsStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.ops.v1.SystemInfo.ops_status)
}
inline ::croupier::ops::v1::OpsStatus* SystemInfo::release_ops_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::croupier::ops::v1::OpsStatus* released = _impl_.ops_status_;
  _impl_.ops_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::croupier::ops::v1::OpsStatus* SystemInfo::unsafe_arena_release_ops_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.SystemInfo.ops_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::croupier::ops::v1::OpsStatus* temp = _impl_.ops_status_;
  _impl_.ops_status_ = nullptr;
  return temp;
}
inline ::croupier::ops::v1::OpsStatus* SystemInfo::_internal_mutable_ops_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ops_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::croupier::ops::v1::OpsStatus>(GetArena());
    _impl_.ops_status_ = reinterpret_cast<::croupier::ops::v1::OpsStatus*>(p);
  }
  return _impl_.ops_status_;
}
inline ::croupier::ops::v1::OpsStatus* SystemInfo::mutable_ops_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::croupier::ops::v1::OpsStatus* _msg = _internal_mutable_ops_status();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.SystemInfo.ops_status)
  return _msg;
}
inline void SystemInfo::set_allocated_ops_status(::croupier::ops::v1::OpsStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::croupier::ops::v1::OpsStatus*>(_impl_.ops_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::croupier::ops::v1::OpsStatus*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ops_status_ = reinterpret_cast<::croupier::ops::v1::OpsStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.SystemInfo.ops_status)
}

// -------------------------------------------------------------------

// OpsStatus

// bool enabled = 1 [json_name = "enabled"];
inline void OpsStatus::clear_enabled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enabled_ = false;
}
inline bool OpsStatus::enabled() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.OpsStatus.enabled)
  return _internal_enabled();
}
inline void OpsStatus::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.OpsStatus.enabled)
}
inline bool OpsStatus::_internal_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enabled_;
}
inline void OpsStatus::_internal_set_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enabled_ = value;
}

// bool allow_restart = 2 [json_name = "allowRestart"];
inline void OpsStatus::clear_allow_restart() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allow_restart_ = false;
}
inline bool OpsStatus::allow_restart() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.OpsStatus.allow_restart)
  return _internal_allow_restart();
}
inline void OpsStatus::set_allow_restart(bool value) {
  _internal_set_allow_restart(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.OpsStatus.allow_restart)
}
inline bool OpsStatus::_internal_allow_restart() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allow_restart_;
}
inline void OpsStatus::_internal_set_allow_restart(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.allow_restart_ = value;
}

// bool allow_exec = 3 [json_name = "allowExec"];
inline void OpsStatus::clear_allow_exec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allow_exec_ = false;
}
inline bool OpsStatus::allow_exec() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.OpsStatus.allow_exec)
  return _internal_allow_exec();
}
inline void OpsStatus::set_allow_exec(bool value) {
  _internal_set_allow_exec(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.OpsStatus.allow_exec)
}
inline bool OpsStatus::_internal_allow_exec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allow_exec_;
}
inline void OpsStatus::_internal_set_allow_exec(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.allow_exec_ = value;
}

// repeated string managed_processes = 4 [json_name = "managedProcesses"];
inline int OpsStatus::_internal_managed_processes_size() const {
  return _internal_managed_processes().size();
}
inline int OpsStatus::managed_processes_size() const {
  return _internal_managed_processes_size();
}
inline void OpsStatus::clear_managed_processes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.managed_processes_.Clear();
}
inline std::string* OpsStatus::add_managed_processes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_managed_processes()->Add();
  // @@protoc_insertion_point(field_add_mutable:croupier.ops.v1.OpsStatus.managed_processes)
  return _s;
}
inline const std::string& OpsStatus::managed_processes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.OpsStatus.managed_processes)
  return _internal_managed_processes().Get(index);
}
inline std::string* OpsStatus::mutable_managed_processes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.OpsStatus.managed_processes)
  return _internal_mutable_managed_processes()->Mutable(index);
}
inline void OpsStatus::set_managed_processes(int index, const std::string& value) {
  _internal_mutable_managed_processes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.OpsStatus.managed_processes)
}
inline void OpsStatus::set_managed_processes(int index, std::string&& value) {
  _internal_mutable_managed_processes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:croupier.ops.v1.OpsStatus.managed_processes)
}
inline void OpsStatus::set_managed_processes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_managed_processes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:croupier.ops.v1.OpsStatus.managed_processes)
}
inline void OpsStatus::set_managed_processes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_managed_processes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:croupier.ops.v1.OpsStatus.managed_processes)
}
inline void OpsStatus::set_managed_processes(int index, absl::string_view value) {
  _internal_mutable_managed_processes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:croupier.ops.v1.OpsStatus.managed_processes)
}
inline void OpsStatus::add_managed_processes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_managed_processes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:croupier.ops.v1.OpsStatus.managed_processes)
}
inline void OpsStatus::add_managed_processes(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_managed_processes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:croupier.ops.v1.OpsStatus.managed_processes)
}
inline void OpsStatus::add_managed_processes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_managed_processes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:croupier.ops.v1.OpsStatus.managed_processes)
}
inline void OpsStatus::add_managed_processes(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_managed_processes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:croupier.ops.v1.OpsStatus.managed_processes)
}
inline void OpsStatus::add_managed_processes(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_managed_processes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:croupier.ops.v1.OpsStatus.managed_processes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
OpsStatus::managed_processes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:croupier.ops.v1.OpsStatus.managed_processes)
  return _internal_managed_processes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
OpsStatus::mutable_managed_processes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:croupier.ops.v1.OpsStatus.managed_processes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_managed_processes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
OpsStatus::_internal_managed_processes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.managed_processes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
OpsStatus::_internal_mutable_managed_processes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.managed_processes_;
}

// -------------------------------------------------------------------

// RestartProcessRequest

// string process_name = 1 [json_name = "processName"];
inline void RestartProcessRequest::clear_process_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.process_name_.ClearToEmpty();
}
inline const std::string& RestartProcessRequest::process_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.RestartProcessRequest.process_name)
  return _internal_process_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RestartProcessRequest::set_process_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.process_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.RestartProcessRequest.process_name)
}
inline std::string* RestartProcessRequest::mutable_process_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_process_name();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.RestartProcessRequest.process_name)
  return _s;
}
inline const std::string& RestartProcessRequest::_internal_process_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.process_name_.Get();
}
inline void RestartProcessRequest::_internal_set_process_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.process_name_.Set(value, GetArena());
}
inline std::string* RestartProcessRequest::_internal_mutable_process_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.process_name_.Mutable( GetArena());
}
inline std::string* RestartProcessRequest::release_process_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.RestartProcessRequest.process_name)
  return _impl_.process_name_.Release();
}
inline void RestartProcessRequest::set_allocated_process_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.process_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.process_name_.IsDefault()) {
          _impl_.process_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.RestartProcessRequest.process_name)
}

// bool force = 2 [json_name = "force"];
inline void RestartProcessRequest::clear_force() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.force_ = false;
}
inline bool RestartProcessRequest::force() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.RestartProcessRequest.force)
  return _internal_force();
}
inline void RestartProcessRequest::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.RestartProcessRequest.force)
}
inline bool RestartProcessRequest::_internal_force() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.force_;
}
inline void RestartProcessRequest::_internal_set_force(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.force_ = value;
}

// int32 timeout_seconds = 3 [json_name = "timeoutSeconds"];
inline void RestartProcessRequest::clear_timeout_seconds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timeout_seconds_ = 0;
}
inline ::int32_t RestartProcessRequest::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.RestartProcessRequest.timeout_seconds)
  return _internal_timeout_seconds();
}
inline void RestartProcessRequest::set_timeout_seconds(::int32_t value) {
  _internal_set_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.RestartProcessRequest.timeout_seconds)
}
inline ::int32_t RestartProcessRequest::_internal_timeout_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timeout_seconds_;
}
inline void RestartProcessRequest::_internal_set_timeout_seconds(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timeout_seconds_ = value;
}

// -------------------------------------------------------------------

// RestartProcessResponse

// bool success = 1 [json_name = "success"];
inline void RestartProcessResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool RestartProcessResponse::success() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.RestartProcessResponse.success)
  return _internal_success();
}
inline void RestartProcessResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.RestartProcessResponse.success)
}
inline bool RestartProcessResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void RestartProcessResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2 [json_name = "message"];
inline void RestartProcessResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RestartProcessResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.RestartProcessResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RestartProcessResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.RestartProcessResponse.message)
}
inline std::string* RestartProcessResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.RestartProcessResponse.message)
  return _s;
}
inline const std::string& RestartProcessResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void RestartProcessResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* RestartProcessResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* RestartProcessResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.RestartProcessResponse.message)
  return _impl_.message_.Release();
}
inline void RestartProcessResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.RestartProcessResponse.message)
}

// int32 new_pid = 3 [json_name = "newPid"];
inline void RestartProcessResponse::clear_new_pid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_pid_ = 0;
}
inline ::int32_t RestartProcessResponse::new_pid() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.RestartProcessResponse.new_pid)
  return _internal_new_pid();
}
inline void RestartProcessResponse::set_new_pid(::int32_t value) {
  _internal_set_new_pid(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.RestartProcessResponse.new_pid)
}
inline ::int32_t RestartProcessResponse::_internal_new_pid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_pid_;
}
inline void RestartProcessResponse::_internal_set_new_pid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_pid_ = value;
}

// -------------------------------------------------------------------

// StopProcessRequest

// string process_name = 1 [json_name = "processName"];
inline void StopProcessRequest::clear_process_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.process_name_.ClearToEmpty();
}
inline const std::string& StopProcessRequest::process_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.StopProcessRequest.process_name)
  return _internal_process_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StopProcessRequest::set_process_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.process_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.StopProcessRequest.process_name)
}
inline std::string* StopProcessRequest::mutable_process_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_process_name();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.StopProcessRequest.process_name)
  return _s;
}
inline const std::string& StopProcessRequest::_internal_process_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.process_name_.Get();
}
inline void StopProcessRequest::_internal_set_process_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.process_name_.Set(value, GetArena());
}
inline std::string* StopProcessRequest::_internal_mutable_process_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.process_name_.Mutable( GetArena());
}
inline std::string* StopProcessRequest::release_process_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.StopProcessRequest.process_name)
  return _impl_.process_name_.Release();
}
inline void StopProcessRequest::set_allocated_process_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.process_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.process_name_.IsDefault()) {
          _impl_.process_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.StopProcessRequest.process_name)
}

// bool force = 2 [json_name = "force"];
inline void StopProcessRequest::clear_force() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.force_ = false;
}
inline bool StopProcessRequest::force() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.StopProcessRequest.force)
  return _internal_force();
}
inline void StopProcessRequest::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.StopProcessRequest.force)
}
inline bool StopProcessRequest::_internal_force() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.force_;
}
inline void StopProcessRequest::_internal_set_force(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.force_ = value;
}

// int32 timeout_seconds = 3 [json_name = "timeoutSeconds"];
inline void StopProcessRequest::clear_timeout_seconds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timeout_seconds_ = 0;
}
inline ::int32_t StopProcessRequest::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.StopProcessRequest.timeout_seconds)
  return _internal_timeout_seconds();
}
inline void StopProcessRequest::set_timeout_seconds(::int32_t value) {
  _internal_set_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.StopProcessRequest.timeout_seconds)
}
inline ::int32_t StopProcessRequest::_internal_timeout_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timeout_seconds_;
}
inline void StopProcessRequest::_internal_set_timeout_seconds(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timeout_seconds_ = value;
}

// -------------------------------------------------------------------

// StopProcessResponse

// bool success = 1 [json_name = "success"];
inline void StopProcessResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool StopProcessResponse::success() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.StopProcessResponse.success)
  return _internal_success();
}
inline void StopProcessResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.StopProcessResponse.success)
}
inline bool StopProcessResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void StopProcessResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2 [json_name = "message"];
inline void StopProcessResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& StopProcessResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.StopProcessResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StopProcessResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.StopProcessResponse.message)
}
inline std::string* StopProcessResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.StopProcessResponse.message)
  return _s;
}
inline const std::string& StopProcessResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void StopProcessResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* StopProcessResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* StopProcessResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.StopProcessResponse.message)
  return _impl_.message_.Release();
}
inline void StopProcessResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.StopProcessResponse.message)
}

// -------------------------------------------------------------------

// StartProcessRequest

// string process_name = 1 [json_name = "processName"];
inline void StartProcessRequest::clear_process_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.process_name_.ClearToEmpty();
}
inline const std::string& StartProcessRequest::process_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.StartProcessRequest.process_name)
  return _internal_process_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StartProcessRequest::set_process_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.process_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.StartProcessRequest.process_name)
}
inline std::string* StartProcessRequest::mutable_process_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_process_name();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.StartProcessRequest.process_name)
  return _s;
}
inline const std::string& StartProcessRequest::_internal_process_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.process_name_.Get();
}
inline void StartProcessRequest::_internal_set_process_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.process_name_.Set(value, GetArena());
}
inline std::string* StartProcessRequest::_internal_mutable_process_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.process_name_.Mutable( GetArena());
}
inline std::string* StartProcessRequest::release_process_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.StartProcessRequest.process_name)
  return _impl_.process_name_.Release();
}
inline void StartProcessRequest::set_allocated_process_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.process_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.process_name_.IsDefault()) {
          _impl_.process_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.StartProcessRequest.process_name)
}

// -------------------------------------------------------------------

// StartProcessResponse

// bool success = 1 [json_name = "success"];
inline void StartProcessResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool StartProcessResponse::success() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.StartProcessResponse.success)
  return _internal_success();
}
inline void StartProcessResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.StartProcessResponse.success)
}
inline bool StartProcessResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void StartProcessResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2 [json_name = "message"];
inline void StartProcessResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& StartProcessResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.StartProcessResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StartProcessResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.StartProcessResponse.message)
}
inline std::string* StartProcessResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.StartProcessResponse.message)
  return _s;
}
inline const std::string& StartProcessResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void StartProcessResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* StartProcessResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* StartProcessResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.StartProcessResponse.message)
  return _impl_.message_.Release();
}
inline void StartProcessResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.StartProcessResponse.message)
}

// int32 pid = 3 [json_name = "pid"];
inline void StartProcessResponse::clear_pid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pid_ = 0;
}
inline ::int32_t StartProcessResponse::pid() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.StartProcessResponse.pid)
  return _internal_pid();
}
inline void StartProcessResponse::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.StartProcessResponse.pid)
}
inline ::int32_t StartProcessResponse::_internal_pid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pid_;
}
inline void StartProcessResponse::_internal_set_pid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pid_ = value;
}

// -------------------------------------------------------------------

// ListProcessesResponse

// repeated .croupier.ops.v1.ManagedProcess processes = 1 [json_name = "processes"];
inline int ListProcessesResponse::_internal_processes_size() const {
  return _internal_processes().size();
}
inline int ListProcessesResponse::processes_size() const {
  return _internal_processes_size();
}
inline void ListProcessesResponse::clear_processes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.processes_.Clear();
}
inline ::croupier::ops::v1::ManagedProcess* ListProcessesResponse::mutable_processes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ListProcessesResponse.processes)
  return _internal_mutable_processes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ManagedProcess>* ListProcessesResponse::mutable_processes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:croupier.ops.v1.ListProcessesResponse.processes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_processes();
}
inline const ::croupier::ops::v1::ManagedProcess& ListProcessesResponse::processes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ListProcessesResponse.processes)
  return _internal_processes().Get(index);
}
inline ::croupier::ops::v1::ManagedProcess* ListProcessesResponse::add_processes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::croupier::ops::v1::ManagedProcess* _add = _internal_mutable_processes()->Add();
  // @@protoc_insertion_point(field_add:croupier.ops.v1.ListProcessesResponse.processes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ManagedProcess>& ListProcessesResponse::processes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:croupier.ops.v1.ListProcessesResponse.processes)
  return _internal_processes();
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ManagedProcess>&
ListProcessesResponse::_internal_processes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.processes_;
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ManagedProcess>*
ListProcessesResponse::_internal_mutable_processes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.processes_;
}

// -------------------------------------------------------------------

// ManagedProcess

// string name = 1 [json_name = "name"];
inline void ManagedProcess::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ManagedProcess::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ManagedProcess.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ManagedProcess::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ManagedProcess.name)
}
inline std::string* ManagedProcess::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ManagedProcess.name)
  return _s;
}
inline const std::string& ManagedProcess::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ManagedProcess::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ManagedProcess::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ManagedProcess::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ManagedProcess.name)
  return _impl_.name_.Release();
}
inline void ManagedProcess::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ManagedProcess.name)
}

// string command = 2 [json_name = "command"];
inline void ManagedProcess::clear_command() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.command_.ClearToEmpty();
}
inline const std::string& ManagedProcess::command() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ManagedProcess.command)
  return _internal_command();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ManagedProcess::set_command(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.command_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ManagedProcess.command)
}
inline std::string* ManagedProcess::mutable_command() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ManagedProcess.command)
  return _s;
}
inline const std::string& ManagedProcess::_internal_command() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.command_.Get();
}
inline void ManagedProcess::_internal_set_command(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.command_.Set(value, GetArena());
}
inline std::string* ManagedProcess::_internal_mutable_command() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.command_.Mutable( GetArena());
}
inline std::string* ManagedProcess::release_command() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ManagedProcess.command)
  return _impl_.command_.Release();
}
inline void ManagedProcess::set_allocated_command(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.command_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.command_.IsDefault()) {
          _impl_.command_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ManagedProcess.command)
}

// string working_dir = 3 [json_name = "workingDir"];
inline void ManagedProcess::clear_working_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.working_dir_.ClearToEmpty();
}
inline const std::string& ManagedProcess::working_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ManagedProcess.working_dir)
  return _internal_working_dir();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ManagedProcess::set_working_dir(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.working_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ManagedProcess.working_dir)
}
inline std::string* ManagedProcess::mutable_working_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_working_dir();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ManagedProcess.working_dir)
  return _s;
}
inline const std::string& ManagedProcess::_internal_working_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.working_dir_.Get();
}
inline void ManagedProcess::_internal_set_working_dir(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.working_dir_.Set(value, GetArena());
}
inline std::string* ManagedProcess::_internal_mutable_working_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.working_dir_.Mutable( GetArena());
}
inline std::string* ManagedProcess::release_working_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ManagedProcess.working_dir)
  return _impl_.working_dir_.Release();
}
inline void ManagedProcess::set_allocated_working_dir(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.working_dir_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.working_dir_.IsDefault()) {
          _impl_.working_dir_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ManagedProcess.working_dir)
}

// .croupier.ops.v1.ProcessState state = 4 [json_name = "state"];
inline void ManagedProcess::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
}
inline ::croupier::ops::v1::ProcessState ManagedProcess::state() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ManagedProcess.state)
  return _internal_state();
}
inline void ManagedProcess::set_state(::croupier::ops::v1::ProcessState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ManagedProcess.state)
}
inline ::croupier::ops::v1::ProcessState ManagedProcess::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::croupier::ops::v1::ProcessState>(_impl_.state_);
}
inline void ManagedProcess::_internal_set_state(::croupier::ops::v1::ProcessState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// int32 pid = 5 [json_name = "pid"];
inline void ManagedProcess::clear_pid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pid_ = 0;
}
inline ::int32_t ManagedProcess::pid() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ManagedProcess.pid)
  return _internal_pid();
}
inline void ManagedProcess::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ManagedProcess.pid)
}
inline ::int32_t ManagedProcess::_internal_pid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pid_;
}
inline void ManagedProcess::_internal_set_pid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pid_ = value;
}

// int32 restart_count = 6 [json_name = "restartCount"];
inline void ManagedProcess::clear_restart_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.restart_count_ = 0;
}
inline ::int32_t ManagedProcess::restart_count() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ManagedProcess.restart_count)
  return _internal_restart_count();
}
inline void ManagedProcess::set_restart_count(::int32_t value) {
  _internal_set_restart_count(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ManagedProcess.restart_count)
}
inline ::int32_t ManagedProcess::_internal_restart_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.restart_count_;
}
inline void ManagedProcess::_internal_set_restart_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.restart_count_ = value;
}

// .google.protobuf.Timestamp last_start = 7 [json_name = "lastStart"];
inline bool ManagedProcess::has_last_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_start_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& ManagedProcess::_internal_last_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.last_start_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& ManagedProcess::last_start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ManagedProcess.last_start)
  return _internal_last_start();
}
inline void ManagedProcess::unsafe_arena_set_allocated_last_start(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_start_);
  }
  _impl_.last_start_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:croupier.ops.v1.ManagedProcess.last_start)
}
inline ::google::protobuf::Timestamp* ManagedProcess::release_last_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.last_start_;
  _impl_.last_start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* ManagedProcess::unsafe_arena_release_last_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ManagedProcess.last_start)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.last_start_;
  _impl_.last_start_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ManagedProcess::_internal_mutable_last_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.last_start_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_start_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_start_;
}
inline ::google::protobuf::Timestamp* ManagedProcess::mutable_last_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_start();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ManagedProcess.last_start)
  return _msg;
}
inline void ManagedProcess::set_allocated_last_start(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_start_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.last_start_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ManagedProcess.last_start)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ExecuteCommandRequest

// string command = 1 [json_name = "command"];
inline void ExecuteCommandRequest::clear_command() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.command_.ClearToEmpty();
}
inline const std::string& ExecuteCommandRequest::command() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ExecuteCommandRequest.command)
  return _internal_command();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecuteCommandRequest::set_command(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.command_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ExecuteCommandRequest.command)
}
inline std::string* ExecuteCommandRequest::mutable_command() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ExecuteCommandRequest.command)
  return _s;
}
inline const std::string& ExecuteCommandRequest::_internal_command() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.command_.Get();
}
inline void ExecuteCommandRequest::_internal_set_command(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.command_.Set(value, GetArena());
}
inline std::string* ExecuteCommandRequest::_internal_mutable_command() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.command_.Mutable( GetArena());
}
inline std::string* ExecuteCommandRequest::release_command() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ExecuteCommandRequest.command)
  return _impl_.command_.Release();
}
inline void ExecuteCommandRequest::set_allocated_command(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.command_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.command_.IsDefault()) {
          _impl_.command_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ExecuteCommandRequest.command)
}

// repeated string args = 2 [json_name = "args"];
inline int ExecuteCommandRequest::_internal_args_size() const {
  return _internal_args().size();
}
inline int ExecuteCommandRequest::args_size() const {
  return _internal_args_size();
}
inline void ExecuteCommandRequest::clear_args() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.args_.Clear();
}
inline std::string* ExecuteCommandRequest::add_args()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_args()->Add();
  // @@protoc_insertion_point(field_add_mutable:croupier.ops.v1.ExecuteCommandRequest.args)
  return _s;
}
inline const std::string& ExecuteCommandRequest::args(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ExecuteCommandRequest.args)
  return _internal_args().Get(index);
}
inline std::string* ExecuteCommandRequest::mutable_args(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ExecuteCommandRequest.args)
  return _internal_mutable_args()->Mutable(index);
}
inline void ExecuteCommandRequest::set_args(int index, const std::string& value) {
  _internal_mutable_args()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ExecuteCommandRequest.args)
}
inline void ExecuteCommandRequest::set_args(int index, std::string&& value) {
  _internal_mutable_args()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ExecuteCommandRequest.args)
}
inline void ExecuteCommandRequest::set_args(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_args()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:croupier.ops.v1.ExecuteCommandRequest.args)
}
inline void ExecuteCommandRequest::set_args(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_args()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:croupier.ops.v1.ExecuteCommandRequest.args)
}
inline void ExecuteCommandRequest::set_args(int index, absl::string_view value) {
  _internal_mutable_args()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:croupier.ops.v1.ExecuteCommandRequest.args)
}
inline void ExecuteCommandRequest::add_args(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:croupier.ops.v1.ExecuteCommandRequest.args)
}
inline void ExecuteCommandRequest::add_args(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:croupier.ops.v1.ExecuteCommandRequest.args)
}
inline void ExecuteCommandRequest::add_args(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:croupier.ops.v1.ExecuteCommandRequest.args)
}
inline void ExecuteCommandRequest::add_args(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:croupier.ops.v1.ExecuteCommandRequest.args)
}
inline void ExecuteCommandRequest::add_args(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:croupier.ops.v1.ExecuteCommandRequest.args)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExecuteCommandRequest::args() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:croupier.ops.v1.ExecuteCommandRequest.args)
  return _internal_args();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExecuteCommandRequest::mutable_args() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:croupier.ops.v1.ExecuteCommandRequest.args)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_args();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExecuteCommandRequest::_internal_args() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.args_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExecuteCommandRequest::_internal_mutable_args() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.args_;
}

// string working_dir = 3 [json_name = "workingDir"];
inline void ExecuteCommandRequest::clear_working_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.working_dir_.ClearToEmpty();
}
inline const std::string& ExecuteCommandRequest::working_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ExecuteCommandRequest.working_dir)
  return _internal_working_dir();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecuteCommandRequest::set_working_dir(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.working_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ExecuteCommandRequest.working_dir)
}
inline std::string* ExecuteCommandRequest::mutable_working_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_working_dir();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ExecuteCommandRequest.working_dir)
  return _s;
}
inline const std::string& ExecuteCommandRequest::_internal_working_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.working_dir_.Get();
}
inline void ExecuteCommandRequest::_internal_set_working_dir(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.working_dir_.Set(value, GetArena());
}
inline std::string* ExecuteCommandRequest::_internal_mutable_working_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.working_dir_.Mutable( GetArena());
}
inline std::string* ExecuteCommandRequest::release_working_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ExecuteCommandRequest.working_dir)
  return _impl_.working_dir_.Release();
}
inline void ExecuteCommandRequest::set_allocated_working_dir(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.working_dir_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.working_dir_.IsDefault()) {
          _impl_.working_dir_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ExecuteCommandRequest.working_dir)
}

// map<string, string> env = 4 [json_name = "env"];
inline int ExecuteCommandRequest::_internal_env_size() const {
  return _internal_env().size();
}
inline int ExecuteCommandRequest::env_size() const {
  return _internal_env_size();
}
inline void ExecuteCommandRequest::clear_env() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.env_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ExecuteCommandRequest::_internal_env() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.env_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ExecuteCommandRequest::env() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:croupier.ops.v1.ExecuteCommandRequest.env)
  return _internal_env();
}
inline ::google::protobuf::Map<std::string, std::string>* ExecuteCommandRequest::_internal_mutable_env() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.env_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ExecuteCommandRequest::mutable_env() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:croupier.ops.v1.ExecuteCommandRequest.env)
  return _internal_mutable_env();
}

// int32 timeout_seconds = 5 [json_name = "timeoutSeconds"];
inline void ExecuteCommandRequest::clear_timeout_seconds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timeout_seconds_ = 0;
}
inline ::int32_t ExecuteCommandRequest::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ExecuteCommandRequest.timeout_seconds)
  return _internal_timeout_seconds();
}
inline void ExecuteCommandRequest::set_timeout_seconds(::int32_t value) {
  _internal_set_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ExecuteCommandRequest.timeout_seconds)
}
inline ::int32_t ExecuteCommandRequest::_internal_timeout_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timeout_seconds_;
}
inline void ExecuteCommandRequest::_internal_set_timeout_seconds(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timeout_seconds_ = value;
}

// -------------------------------------------------------------------

// ExecuteCommandResponse

// bool success = 1 [json_name = "success"];
inline void ExecuteCommandResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool ExecuteCommandResponse::success() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ExecuteCommandResponse.success)
  return _internal_success();
}
inline void ExecuteCommandResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ExecuteCommandResponse.success)
}
inline bool ExecuteCommandResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void ExecuteCommandResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// int32 exit_code = 2 [json_name = "exitCode"];
inline void ExecuteCommandResponse::clear_exit_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exit_code_ = 0;
}
inline ::int32_t ExecuteCommandResponse::exit_code() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ExecuteCommandResponse.exit_code)
  return _internal_exit_code();
}
inline void ExecuteCommandResponse::set_exit_code(::int32_t value) {
  _internal_set_exit_code(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ExecuteCommandResponse.exit_code)
}
inline ::int32_t ExecuteCommandResponse::_internal_exit_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exit_code_;
}
inline void ExecuteCommandResponse::_internal_set_exit_code(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.exit_code_ = value;
}

// string std_out = 3 [json_name = "stdOut"];
inline void ExecuteCommandResponse::clear_std_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.std_out_.ClearToEmpty();
}
inline const std::string& ExecuteCommandResponse::std_out() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ExecuteCommandResponse.std_out)
  return _internal_std_out();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecuteCommandResponse::set_std_out(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.std_out_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ExecuteCommandResponse.std_out)
}
inline std::string* ExecuteCommandResponse::mutable_std_out() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_std_out();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ExecuteCommandResponse.std_out)
  return _s;
}
inline const std::string& ExecuteCommandResponse::_internal_std_out() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.std_out_.Get();
}
inline void ExecuteCommandResponse::_internal_set_std_out(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.std_out_.Set(value, GetArena());
}
inline std::string* ExecuteCommandResponse::_internal_mutable_std_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.std_out_.Mutable( GetArena());
}
inline std::string* ExecuteCommandResponse::release_std_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ExecuteCommandResponse.std_out)
  return _impl_.std_out_.Release();
}
inline void ExecuteCommandResponse::set_allocated_std_out(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.std_out_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.std_out_.IsDefault()) {
          _impl_.std_out_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ExecuteCommandResponse.std_out)
}

// string std_err = 4 [json_name = "stdErr"];
inline void ExecuteCommandResponse::clear_std_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.std_err_.ClearToEmpty();
}
inline const std::string& ExecuteCommandResponse::std_err() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ExecuteCommandResponse.std_err)
  return _internal_std_err();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecuteCommandResponse::set_std_err(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.std_err_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ExecuteCommandResponse.std_err)
}
inline std::string* ExecuteCommandResponse::mutable_std_err() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_std_err();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ExecuteCommandResponse.std_err)
  return _s;
}
inline const std::string& ExecuteCommandResponse::_internal_std_err() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.std_err_.Get();
}
inline void ExecuteCommandResponse::_internal_set_std_err(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.std_err_.Set(value, GetArena());
}
inline std::string* ExecuteCommandResponse::_internal_mutable_std_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.std_err_.Mutable( GetArena());
}
inline std::string* ExecuteCommandResponse::release_std_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ExecuteCommandResponse.std_err)
  return _impl_.std_err_.Release();
}
inline void ExecuteCommandResponse::set_allocated_std_err(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.std_err_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.std_err_.IsDefault()) {
          _impl_.std_err_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ExecuteCommandResponse.std_err)
}

// string error = 5 [json_name = "error"];
inline void ExecuteCommandResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& ExecuteCommandResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ExecuteCommandResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecuteCommandResponse::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ExecuteCommandResponse.error)
}
inline std::string* ExecuteCommandResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ExecuteCommandResponse.error)
  return _s;
}
inline const std::string& ExecuteCommandResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void ExecuteCommandResponse::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_.Set(value, GetArena());
}
inline std::string* ExecuteCommandResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* ExecuteCommandResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ExecuteCommandResponse.error)
  return _impl_.error_.Release();
}
inline void ExecuteCommandResponse::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ExecuteCommandResponse.error)
}

// -------------------------------------------------------------------

// ListServicesRequest

// string state = 1 [json_name = "state"];
inline void ListServicesRequest::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_.ClearToEmpty();
}
inline const std::string& ListServicesRequest::state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ListServicesRequest.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListServicesRequest::set_state(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ListServicesRequest.state)
}
inline std::string* ListServicesRequest::mutable_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ListServicesRequest.state)
  return _s;
}
inline const std::string& ListServicesRequest::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_.Get();
}
inline void ListServicesRequest::_internal_set_state(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_.Set(value, GetArena());
}
inline std::string* ListServicesRequest::_internal_mutable_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.state_.Mutable( GetArena());
}
inline std::string* ListServicesRequest::release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ListServicesRequest.state)
  return _impl_.state_.Release();
}
inline void ListServicesRequest::set_allocated_state(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ListServicesRequest.state)
}

// string name_pattern = 2 [json_name = "namePattern"];
inline void ListServicesRequest::clear_name_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_pattern_.ClearToEmpty();
}
inline const std::string& ListServicesRequest::name_pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ListServicesRequest.name_pattern)
  return _internal_name_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListServicesRequest::set_name_pattern(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ListServicesRequest.name_pattern)
}
inline std::string* ListServicesRequest::mutable_name_pattern() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name_pattern();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ListServicesRequest.name_pattern)
  return _s;
}
inline const std::string& ListServicesRequest::_internal_name_pattern() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_pattern_.Get();
}
inline void ListServicesRequest::_internal_set_name_pattern(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_pattern_.Set(value, GetArena());
}
inline std::string* ListServicesRequest::_internal_mutable_name_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_pattern_.Mutable( GetArena());
}
inline std::string* ListServicesRequest::release_name_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ListServicesRequest.name_pattern)
  return _impl_.name_pattern_.Release();
}
inline void ListServicesRequest::set_allocated_name_pattern(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_pattern_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_pattern_.IsDefault()) {
          _impl_.name_pattern_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ListServicesRequest.name_pattern)
}

// int32 limit = 3 [json_name = "limit"];
inline void ListServicesRequest::clear_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.limit_ = 0;
}
inline ::int32_t ListServicesRequest::limit() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ListServicesRequest.limit)
  return _internal_limit();
}
inline void ListServicesRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ListServicesRequest.limit)
}
inline ::int32_t ListServicesRequest::_internal_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_;
}
inline void ListServicesRequest::_internal_set_limit(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// ListServicesResponse

// repeated .croupier.ops.v1.ServiceInfo services = 1 [json_name = "services"];
inline int ListServicesResponse::_internal_services_size() const {
  return _internal_services().size();
}
inline int ListServicesResponse::services_size() const {
  return _internal_services_size();
}
inline void ListServicesResponse::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::croupier::ops::v1::ServiceInfo* ListServicesResponse::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ListServicesResponse.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ServiceInfo>* ListServicesResponse::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:croupier.ops.v1.ListServicesResponse.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::croupier::ops::v1::ServiceInfo& ListServicesResponse::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ListServicesResponse.services)
  return _internal_services().Get(index);
}
inline ::croupier::ops::v1::ServiceInfo* ListServicesResponse::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::croupier::ops::v1::ServiceInfo* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:croupier.ops.v1.ListServicesResponse.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ServiceInfo>& ListServicesResponse::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:croupier.ops.v1.ListServicesResponse.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ServiceInfo>&
ListServicesResponse::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::ServiceInfo>*
ListServicesResponse::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// int32 total = 2 [json_name = "total"];
inline void ListServicesResponse::clear_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_ = 0;
}
inline ::int32_t ListServicesResponse::total() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ListServicesResponse.total)
  return _internal_total();
}
inline void ListServicesResponse::set_total(::int32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ListServicesResponse.total)
}
inline ::int32_t ListServicesResponse::_internal_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_;
}
inline void ListServicesResponse::_internal_set_total(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_ = value;
}

// -------------------------------------------------------------------

// ServiceInfo

// string name = 1 [json_name = "name"];
inline void ServiceInfo::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ServiceInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ServiceInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ServiceInfo.name)
}
inline std::string* ServiceInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ServiceInfo.name)
  return _s;
}
inline const std::string& ServiceInfo::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ServiceInfo::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ServiceInfo::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ServiceInfo::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ServiceInfo.name)
  return _impl_.name_.Release();
}
inline void ServiceInfo::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ServiceInfo.name)
}

// string display_name = 2 [json_name = "displayName"];
inline void ServiceInfo::clear_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& ServiceInfo::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ServiceInfo.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceInfo::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ServiceInfo.display_name)
}
inline std::string* ServiceInfo::mutable_display_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ServiceInfo.display_name)
  return _s;
}
inline const std::string& ServiceInfo::_internal_display_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.display_name_.Get();
}
inline void ServiceInfo::_internal_set_display_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(value, GetArena());
}
inline std::string* ServiceInfo::_internal_mutable_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.display_name_.Mutable( GetArena());
}
inline std::string* ServiceInfo::release_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ServiceInfo.display_name)
  return _impl_.display_name_.Release();
}
inline void ServiceInfo::set_allocated_display_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.display_name_.IsDefault()) {
          _impl_.display_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ServiceInfo.display_name)
}

// string status = 3 [json_name = "status"];
inline void ServiceInfo::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ServiceInfo::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ServiceInfo.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceInfo::set_status(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ServiceInfo.status)
}
inline std::string* ServiceInfo::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ServiceInfo.status)
  return _s;
}
inline const std::string& ServiceInfo::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_.Get();
}
inline void ServiceInfo::_internal_set_status(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_.Set(value, GetArena());
}
inline std::string* ServiceInfo::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* ServiceInfo::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ServiceInfo.status)
  return _impl_.status_.Release();
}
inline void ServiceInfo::set_allocated_status(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ServiceInfo.status)
}

// string start_type = 4 [json_name = "startType"];
inline void ServiceInfo::clear_start_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_type_.ClearToEmpty();
}
inline const std::string& ServiceInfo::start_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ServiceInfo.start_type)
  return _internal_start_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceInfo::set_start_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ServiceInfo.start_type)
}
inline std::string* ServiceInfo::mutable_start_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_type();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ServiceInfo.start_type)
  return _s;
}
inline const std::string& ServiceInfo::_internal_start_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_type_.Get();
}
inline void ServiceInfo::_internal_set_start_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_type_.Set(value, GetArena());
}
inline std::string* ServiceInfo::_internal_mutable_start_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.start_type_.Mutable( GetArena());
}
inline std::string* ServiceInfo::release_start_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.ServiceInfo.start_type)
  return _impl_.start_type_.Release();
}
inline void ServiceInfo::set_allocated_start_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.start_type_.IsDefault()) {
          _impl_.start_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.ServiceInfo.start_type)
}

// uint32 process_id = 5 [json_name = "processId"];
inline void ServiceInfo::clear_process_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.process_id_ = 0u;
}
inline ::uint32_t ServiceInfo::process_id() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ServiceInfo.process_id)
  return _internal_process_id();
}
inline void ServiceInfo::set_process_id(::uint32_t value) {
  _internal_set_process_id(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ServiceInfo.process_id)
}
inline ::uint32_t ServiceInfo::_internal_process_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.process_id_;
}
inline void ServiceInfo::_internal_set_process_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.process_id_ = value;
}

// -------------------------------------------------------------------

// GetServiceStatusRequest

// string name = 1 [json_name = "name"];
inline void GetServiceStatusRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetServiceStatusRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.GetServiceStatusRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetServiceStatusRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.GetServiceStatusRequest.name)
}
inline std::string* GetServiceStatusRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.GetServiceStatusRequest.name)
  return _s;
}
inline const std::string& GetServiceStatusRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetServiceStatusRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetServiceStatusRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetServiceStatusRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.GetServiceStatusRequest.name)
  return _impl_.name_.Release();
}
inline void GetServiceStatusRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.GetServiceStatusRequest.name)
}

// -------------------------------------------------------------------

// GetServiceStatusResponse

// string name = 1 [json_name = "name"];
inline void GetServiceStatusResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetServiceStatusResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.GetServiceStatusResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetServiceStatusResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.GetServiceStatusResponse.name)
}
inline std::string* GetServiceStatusResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.GetServiceStatusResponse.name)
  return _s;
}
inline const std::string& GetServiceStatusResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetServiceStatusResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetServiceStatusResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetServiceStatusResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.GetServiceStatusResponse.name)
  return _impl_.name_.Release();
}
inline void GetServiceStatusResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.GetServiceStatusResponse.name)
}

// string display_name = 2 [json_name = "displayName"];
inline void GetServiceStatusResponse::clear_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& GetServiceStatusResponse::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.GetServiceStatusResponse.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetServiceStatusResponse::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.GetServiceStatusResponse.display_name)
}
inline std::string* GetServiceStatusResponse::mutable_display_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.GetServiceStatusResponse.display_name)
  return _s;
}
inline const std::string& GetServiceStatusResponse::_internal_display_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.display_name_.Get();
}
inline void GetServiceStatusResponse::_internal_set_display_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(value, GetArena());
}
inline std::string* GetServiceStatusResponse::_internal_mutable_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.display_name_.Mutable( GetArena());
}
inline std::string* GetServiceStatusResponse::release_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.GetServiceStatusResponse.display_name)
  return _impl_.display_name_.Release();
}
inline void GetServiceStatusResponse::set_allocated_display_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.display_name_.IsDefault()) {
          _impl_.display_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.GetServiceStatusResponse.display_name)
}

// string status = 3 [json_name = "status"];
inline void GetServiceStatusResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& GetServiceStatusResponse::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.GetServiceStatusResponse.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetServiceStatusResponse::set_status(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.GetServiceStatusResponse.status)
}
inline std::string* GetServiceStatusResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.GetServiceStatusResponse.status)
  return _s;
}
inline const std::string& GetServiceStatusResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_.Get();
}
inline void GetServiceStatusResponse::_internal_set_status(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_.Set(value, GetArena());
}
inline std::string* GetServiceStatusResponse::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* GetServiceStatusResponse::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.GetServiceStatusResponse.status)
  return _impl_.status_.Release();
}
inline void GetServiceStatusResponse::set_allocated_status(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.GetServiceStatusResponse.status)
}

// string start_type = 4 [json_name = "startType"];
inline void GetServiceStatusResponse::clear_start_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_type_.ClearToEmpty();
}
inline const std::string& GetServiceStatusResponse::start_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.GetServiceStatusResponse.start_type)
  return _internal_start_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetServiceStatusResponse::set_start_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.GetServiceStatusResponse.start_type)
}
inline std::string* GetServiceStatusResponse::mutable_start_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_type();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.GetServiceStatusResponse.start_type)
  return _s;
}
inline const std::string& GetServiceStatusResponse::_internal_start_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_type_.Get();
}
inline void GetServiceStatusResponse::_internal_set_start_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_type_.Set(value, GetArena());
}
inline std::string* GetServiceStatusResponse::_internal_mutable_start_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.start_type_.Mutable( GetArena());
}
inline std::string* GetServiceStatusResponse::release_start_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.GetServiceStatusResponse.start_type)
  return _impl_.start_type_.Release();
}
inline void GetServiceStatusResponse::set_allocated_start_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.start_type_.IsDefault()) {
          _impl_.start_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.GetServiceStatusResponse.start_type)
}

// uint32 process_id = 5 [json_name = "processId"];
inline void GetServiceStatusResponse::clear_process_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.process_id_ = 0u;
}
inline ::uint32_t GetServiceStatusResponse::process_id() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.GetServiceStatusResponse.process_id)
  return _internal_process_id();
}
inline void GetServiceStatusResponse::set_process_id(::uint32_t value) {
  _internal_set_process_id(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.GetServiceStatusResponse.process_id)
}
inline ::uint32_t GetServiceStatusResponse::_internal_process_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.process_id_;
}
inline void GetServiceStatusResponse::_internal_set_process_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.process_id_ = value;
}

// string binary_path = 6 [json_name = "binaryPath"];
inline void GetServiceStatusResponse::clear_binary_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_path_.ClearToEmpty();
}
inline const std::string& GetServiceStatusResponse::binary_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.GetServiceStatusResponse.binary_path)
  return _internal_binary_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetServiceStatusResponse::set_binary_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.binary_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.GetServiceStatusResponse.binary_path)
}
inline std::string* GetServiceStatusResponse::mutable_binary_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_binary_path();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.GetServiceStatusResponse.binary_path)
  return _s;
}
inline const std::string& GetServiceStatusResponse::_internal_binary_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.binary_path_.Get();
}
inline void GetServiceStatusResponse::_internal_set_binary_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.binary_path_.Set(value, GetArena());
}
inline std::string* GetServiceStatusResponse::_internal_mutable_binary_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.binary_path_.Mutable( GetArena());
}
inline std::string* GetServiceStatusResponse::release_binary_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.GetServiceStatusResponse.binary_path)
  return _impl_.binary_path_.Release();
}
inline void GetServiceStatusResponse::set_allocated_binary_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.binary_path_.IsDefault()) {
          _impl_.binary_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.GetServiceStatusResponse.binary_path)
}

// string description = 7 [json_name = "description"];
inline void GetServiceStatusResponse::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& GetServiceStatusResponse::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.GetServiceStatusResponse.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetServiceStatusResponse::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.GetServiceStatusResponse.description)
}
inline std::string* GetServiceStatusResponse::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.GetServiceStatusResponse.description)
  return _s;
}
inline const std::string& GetServiceStatusResponse::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void GetServiceStatusResponse::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* GetServiceStatusResponse::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* GetServiceStatusResponse::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.GetServiceStatusResponse.description)
  return _impl_.description_.Release();
}
inline void GetServiceStatusResponse::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.GetServiceStatusResponse.description)
}

// -------------------------------------------------------------------

// ListCronJobsResponse

// repeated .croupier.ops.v1.CronJob jobs = 1 [json_name = "jobs"];
inline int ListCronJobsResponse::_internal_jobs_size() const {
  return _internal_jobs().size();
}
inline int ListCronJobsResponse::jobs_size() const {
  return _internal_jobs_size();
}
inline void ListCronJobsResponse::clear_jobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobs_.Clear();
}
inline ::croupier::ops::v1::CronJob* ListCronJobsResponse::mutable_jobs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.ListCronJobsResponse.jobs)
  return _internal_mutable_jobs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::CronJob>* ListCronJobsResponse::mutable_jobs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:croupier.ops.v1.ListCronJobsResponse.jobs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jobs();
}
inline const ::croupier::ops::v1::CronJob& ListCronJobsResponse::jobs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ListCronJobsResponse.jobs)
  return _internal_jobs().Get(index);
}
inline ::croupier::ops::v1::CronJob* ListCronJobsResponse::add_jobs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::croupier::ops::v1::CronJob* _add = _internal_mutable_jobs()->Add();
  // @@protoc_insertion_point(field_add:croupier.ops.v1.ListCronJobsResponse.jobs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::CronJob>& ListCronJobsResponse::jobs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:croupier.ops.v1.ListCronJobsResponse.jobs)
  return _internal_jobs();
}
inline const ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::CronJob>&
ListCronJobsResponse::_internal_jobs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobs_;
}
inline ::google::protobuf::RepeatedPtrField<::croupier::ops::v1::CronJob>*
ListCronJobsResponse::_internal_mutable_jobs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jobs_;
}

// int32 total = 2 [json_name = "total"];
inline void ListCronJobsResponse::clear_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_ = 0;
}
inline ::int32_t ListCronJobsResponse::total() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.ListCronJobsResponse.total)
  return _internal_total();
}
inline void ListCronJobsResponse::set_total(::int32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.ListCronJobsResponse.total)
}
inline ::int32_t ListCronJobsResponse::_internal_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_;
}
inline void ListCronJobsResponse::_internal_set_total(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_ = value;
}

// -------------------------------------------------------------------

// CronJob

// string schedule = 1 [json_name = "schedule"];
inline void CronJob::clear_schedule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schedule_.ClearToEmpty();
}
inline const std::string& CronJob::schedule() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.CronJob.schedule)
  return _internal_schedule();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CronJob::set_schedule(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.schedule_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.CronJob.schedule)
}
inline std::string* CronJob::mutable_schedule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.CronJob.schedule)
  return _s;
}
inline const std::string& CronJob::_internal_schedule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.schedule_.Get();
}
inline void CronJob::_internal_set_schedule(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.schedule_.Set(value, GetArena());
}
inline std::string* CronJob::_internal_mutable_schedule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.schedule_.Mutable( GetArena());
}
inline std::string* CronJob::release_schedule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.CronJob.schedule)
  return _impl_.schedule_.Release();
}
inline void CronJob::set_allocated_schedule(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schedule_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schedule_.IsDefault()) {
          _impl_.schedule_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.CronJob.schedule)
}

// string command = 2 [json_name = "command"];
inline void CronJob::clear_command() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.command_.ClearToEmpty();
}
inline const std::string& CronJob::command() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.CronJob.command)
  return _internal_command();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CronJob::set_command(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.command_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.CronJob.command)
}
inline std::string* CronJob::mutable_command() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.CronJob.command)
  return _s;
}
inline const std::string& CronJob::_internal_command() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.command_.Get();
}
inline void CronJob::_internal_set_command(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.command_.Set(value, GetArena());
}
inline std::string* CronJob::_internal_mutable_command() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.command_.Mutable( GetArena());
}
inline std::string* CronJob::release_command() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.CronJob.command)
  return _impl_.command_.Release();
}
inline void CronJob::set_allocated_command(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.command_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.command_.IsDefault()) {
          _impl_.command_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.CronJob.command)
}

// string user = 3 [json_name = "user"];
inline void CronJob::clear_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_.ClearToEmpty();
}
inline const std::string& CronJob::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.CronJob.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CronJob::set_user(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.CronJob.user)
}
inline std::string* CronJob::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.CronJob.user)
  return _s;
}
inline const std::string& CronJob::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_.Get();
}
inline void CronJob::_internal_set_user(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_.Set(value, GetArena());
}
inline std::string* CronJob::_internal_mutable_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_.Mutable( GetArena());
}
inline std::string* CronJob::release_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.CronJob.user)
  return _impl_.user_.Release();
}
inline void CronJob::set_allocated_user(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_.IsDefault()) {
          _impl_.user_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.CronJob.user)
}

// string source_file = 4 [json_name = "sourceFile"];
inline void CronJob::clear_source_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_file_.ClearToEmpty();
}
inline const std::string& CronJob::source_file() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.CronJob.source_file)
  return _internal_source_file();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CronJob::set_source_file(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_file_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:croupier.ops.v1.CronJob.source_file)
}
inline std::string* CronJob::mutable_source_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_file();
  // @@protoc_insertion_point(field_mutable:croupier.ops.v1.CronJob.source_file)
  return _s;
}
inline const std::string& CronJob::_internal_source_file() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_file_.Get();
}
inline void CronJob::_internal_set_source_file(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_file_.Set(value, GetArena());
}
inline std::string* CronJob::_internal_mutable_source_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.source_file_.Mutable( GetArena());
}
inline std::string* CronJob::release_source_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:croupier.ops.v1.CronJob.source_file)
  return _impl_.source_file_.Release();
}
inline void CronJob::set_allocated_source_file(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_file_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_file_.IsDefault()) {
          _impl_.source_file_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:croupier.ops.v1.CronJob.source_file)
}

// bool enabled = 5 [json_name = "enabled"];
inline void CronJob::clear_enabled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enabled_ = false;
}
inline bool CronJob::enabled() const {
  // @@protoc_insertion_point(field_get:croupier.ops.v1.CronJob.enabled)
  return _internal_enabled();
}
inline void CronJob::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:croupier.ops.v1.CronJob.enabled)
}
inline bool CronJob::_internal_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enabled_;
}
inline void CronJob::_internal_set_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enabled_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace ops
}  // namespace croupier


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::croupier::ops::v1::ProcessState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::croupier::ops::v1::ProcessState>() {
  return ::croupier::ops::v1::ProcessState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_croupier_2fops_2fv1_2fops_2eproto_2epb_2eh
